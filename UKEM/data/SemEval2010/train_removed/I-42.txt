a complete distributed constraint optimization method 
for non-traditional pseudotree arrangements 
james atlas 
computer and information sciences 
university of delaware 
newark de 
atlas cis udel edu 
keith decker 
computer and information sciences 
university of delaware 
newark de 
decker cis udel edu 
abstract 
distributed constraint optimization dcop is a general 
framework that can model complex problems in multi-agent systems 
several current algorithms that solve general dcop instances 
including adopt and dpop arrange agents into a traditional 
pseudotree structure we introduce an extension to the dpop algorithm 
that handles an extended set of pseudotree arrangements our 
algorithm correctly solves dcop instances for pseudotrees that 
include edges between nodes in separate branches the algorithm 
also solves instances with traditional pseudotree arrangements 
using the same procedure as dpop 
we compare our algorithm with dpop using several metrics 
including the induced width of the pseudotrees the maximum 
dimensionality of messages and computation and the maximum 
sequential path cost through the algorithm we prove that for some 
problem instances it is not possible to generate a traditional pseudotree 
using edge-traversal heuristics that will outperform a cross-edged 
pseudotree we use multiple heuristics to generate pseudotrees and 
choose the best pseudotree in linear space-time complexity for 
some problem instances we observe significant improvements in 
message and computation sizes compared to dpop 
categories and subject descriptors 
i artificial intelligence distributed artificial 
intelligence-multiagent systems 
general terms 
algorithms 
 introduction 
many historical problems in the ai community can be 
transformed into constraint satisfaction problems csp with the 
advent of distributed ai multi-agent systems became a popular way 
to model the complex interactions and coordination required to 
solve distributed problems csps were originally extended to 
distributed agent environments in early domains for 
distributed constraint satisfaction problems discsp included job 
shop scheduling and resource allocation many domains 
for agent systems especially teamwork coordination distributed 
scheduling and sensor networks involve overly constrained 
problems that are difficult or impossible to satisfy for every constraint 
recent approaches to solving problems in these domains rely 
on optimization techniques that map constraints into multi-valued 
utility functions instead of finding an assignment that satisfies all 
constraints these approaches find an assignment that produces a 
high level of global utility this extension to the original discsp 
approach has become popular in multi-agent systems and has been 
labeled the distributed constraint optimization problem dcop 
 
current algorithms that solve complete dcops use two main 
approaches search and dynamic programming search based 
algorithms that originated from discsp typically use some form of 
backtracking or bounds propagation as in adopt 
dynamic programming based algorithms include dpop and its 
extensions to date both categories of algorithms arrange 
agents into a traditional pseudotree to solve the problem 
it has been shown in that any constraint graph can be mapped 
into a traditional pseudotree however it was also shown that 
finding the optimal pseudotree was np-hard we began to 
investigate the performance of traditional pseudotrees generated by 
current edge-traversal heuristics we found that these heuristics 
often produced little parallelism as the pseudotrees tended to have 
high depth and low branching factors we suspected that there 
could be other ways to arrange the pseudotrees that would 
provide increased parallelism and smaller message sizes after 
exploring these other arrangements we found that cross-edged 
pseudotrees provide shorter depths and higher branching factors than 
the traditional pseudotrees our hypothesis was that these 
crossedged pseudotrees would outperform traditional pseudotrees for 
some problem types 
in this paper we introduce an extension to the dpop algorithm 
that handles an extended set of pseudotree arrangements which 
include cross-edged pseudotrees we begin with a definition of 
 
 - - - - rps c ifaamas 
dcop traditional pseudotrees and cross-edged pseudotrees we 
then provide a summary of the original dpop algorithm and 
introduce our dcpop algorithm we discuss the complexity of our 
algorithm as well as the impact of pseudotree generation 
heuristics we then show that our distributed cross-edged pseudotree 
optimization procedure dcpop performs significantly better in 
practice than the original dpop algorithm for some problem 
instances we conclude with a selection of ideas for future work and 
extensions for dcpop 
 problem definition 
dcop has been formalized in slightly different ways in recent 
literature so we will adopt the definition as presented in a 
distributed constraint optimization problem with n nodes and m 
constraints consists of the tuple x d u where 
 x x xn is a set of variables each one assigned to a 
unique agent 
 d d dn is a set of finite domains for each variable 
 u u um is a set of utility functions such that each 
function involves a subset of variables in x and defines a 
utility for each combination of values among these variables 
an optimal solution to a dcop instance consists of an assignment 
of values in d to x such that the sum of utilities in u is maximal 
problem domains that require minimum cost instead of maximum 
utility can map costs into negative utilities the utility functions 
represent soft constraints but can also represent hard constraints 
by using arbitrarily large negative values for this paper we only 
consider binary utility functions involving two variables higher 
order utility functions can be modeled with minor changes to the 
algorithm but they also substantially increase the complexity 
 traditional pseudotrees 
pseudotrees are a common structure used in search procedures 
to allow parallel processing of independent branches as defined in 
 a pseudotree is an arrangement of a graph g into a rooted tree 
t such that vertices in g that share an edge are in the same branch 
in t a back-edge is an edge between a node x and any node which 
lies on the path from x to the root excluding x s parent figure 
shows a pseudotree with four nodes three edges a-b b-c 
bd and one back-edge a-c also defined in are four types of 
relationships between nodes exist in a pseudotree 
 p x - the parent of a node x the single node higher in the 
pseudotree that is connected to x directly through a tree edge 
 c x - the children of a node x the set of nodes lower in 
the pseudotree that are connected to x directly through tree 
edges 
 pp x - the pseudo-parents of a node x the set of nodes 
higher in the pseudotree that are connected to x directly 
through back-edges in figure a pp c 
 pc x - the pseudo-children of a node x the set of nodes 
lower in the pseudotree that are connected to x directly 
through back-edges in figure c pc a 
figure a traditional pseudotree solid line edges 
represent parent-child relationships and the dashed line represents 
a pseudo-parent-pseudo-child relationship 
figure a cross-edged pseudotree solid line edges represent 
parent-child relationships the dashed line represents a 
pseudoparent-pseudo-child relationship and the dotted line 
represents a branch-parent-branch-child relationship the bolded 
node b is the merge point for node e 
 cross-edged pseudotrees 
we define a cross-edge as an edge from node x to a node y that is 
above x but not in the path from x to the root a cross-edged 
pseudotree is a traditional pseudotree with the addition of cross-edges 
figure shows a cross-edged pseudotree with a cross-edge d-e 
in a cross-edged pseudotree we designate certain edges as primary 
the set of primary edges defines a spanning tree of the nodes the 
parent child pseudo-parent and pseudo-child relationships from 
the traditional pseudotree are now defined in the context of this 
primary edge spanning tree this definition also yields two additional 
types of relationships that may exist between nodes 
 bp x - the branch-parents of a node x the set of nodes 
higher in the pseudotree that are connected to x but are not 
in the primary path from x to the root in figure d 
bp e 
 bc x - the branch-children of a node x the set of nodes 
lower in the pseudotree that are connected to x but are not in 
any primary path from x to any leaf node in figure e 
bc d 
 pseudotree generation 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
current algorithms usually have a pre-execution phase to 
generate a traditional pseudotree from a general dcop instance our 
dcpop algorithm generates a cross-edged pseudotree in the same 
fashion first the dcop instance x d u translates directly 
into a graph with x as the set of vertices and an edge for each pair 
of variables represented in u next various heuristics are used to 
arrange this graph into a pseudotree one common heuristic is to 
perform a guided depth-first search dfs as the resulting traversal 
is a pseudotree and a dfs can easily be performed in a distributed 
fashion we define an edge-traversal based method as any method 
that produces a pseudotree in which all parent child pairs share an 
edge in the original graph this includes dfs breadth-first search 
and best-first search based traversals our heuristics that generate 
cross-edged pseudotrees use a distributed best-first search traversal 
 dpop algorithm 
the original dpop algorithm operates in three main phases the 
first phase generates a traditional pseudotree from the dcop 
instance using a distributed algorithm the second phase joins utility 
hypercubes from children and the local node and propagates them 
towards the root the third phase chooses an assignment for each 
domain in a top down fashion beginning with the agent at the root 
node 
the complexity of dpop depends on the size of the largest 
computation and utility message during phase two it has been shown 
that this size directly corresponds to the induced width of the 
pseudotree generated in phase one dpop uses polynomial time 
heuristics to generate the pseudotree since finding the minimum 
induced width pseudotree is np-hard several distributed 
edgetraversal heuristics have been developed to find low width 
pseudotrees at the end of the first phase each agent knows its 
parent children pseudo-parents and pseudo-children 
 utility propagation 
agents located at leaf nodes in the pseudotree begin the process 
by calculating a local utility hypercube this hypercube at node 
x contains summed utilities for each combination of values in the 
domains for p x and pp x this hypercube has dimensional size 
equal to the number of pseudo-parents plus one a message 
containing this hypercube is sent to p x agents located at non-leaf 
nodes wait for all messages from children to arrive once the agent 
at node y has all utility messages it calculates its local utility 
hypercube which includes domains for p y pp y and y the local 
utility hypercube is then joined with all of the hypercubes from 
the child messages at this point all utilities involving node y are 
known and the domain for y may be safely eliminated from the 
joined hypercube this elimination process chooses the best utility 
over the domain of y for each combination of the remaining 
domains a message containing this hypercube is now sent to p y 
the dimensional size of this hypercube depends on the number of 
overlapping domains in received messages and the local utility 
hypercube this dynamic programming based propagation phase 
continues until the agent at the root node of the pseudotree has received 
all messages from its children 
 value propagation 
value propagation begins when the agent at the root node z has 
received all messages from its children since z has no parents 
or pseudo-parents it simply combines the utility hypercubes 
received from its children the combined hypercube contains only 
values for the domain for z at this point the agent at node z 
simply chooses the assignment for its domain that has the best utility 
a value propagation message with this assignment is sent to each 
node in c z each other node then receives a value propagation 
message from its parent and chooses the assignment for its domain 
that has the best utility given the assignments received in the 
message the node adds its domain assignment to the assignments it 
received and passes the set of assignments to its children the 
algorithm is complete when all nodes have chosen an assignment for 
their domain 
 dcpop algorithm 
our extension to the original dpop algorithm shown in 
algorithm shares the same three phases the first phase generates the 
cross-edged pseudotree for the dcop instance the second phase 
merges branches and propagates the utility hypercubes the third 
phase chooses assignments for domains at branch merge points and 
in a top down fashion beginning with the agent at the root node 
for the first phase we generate a pseudotree using several 
distributed heuristics and select the one with lowest overall 
complexity the complexity of the computation and utility message size 
in dcpop does not directly correspond to the induced width of 
the cross-edged pseudotree instead we use a polynomial time 
method for calculating the maximum computation and utility 
message size for a given cross-edged pseudotree a description of 
this method and the pseudotree selection process appears in 
section at the end of the first phase each agent knows its 
parent children pseudo-parents pseudo-children branch-parents and 
branch-children 
 merging branches and utility 
propagation 
in the original dpop algorithm a node x only had utility 
functions involving its parent and its pseudo-parents in dcpop a node 
x is allowed to have a utility function involving a branch-parent 
the concept of a branch can be seen in figure with node e 
representing our node x the two distinct paths from node e to node 
b are called branches of e the single node where all branches of 
e meet is node b which is called the merge point of e 
agents with nodes that have branch-parents begin by sending 
a utility propagation message to each branch-parent this 
message includes a two dimensional utility hypercube with domains for 
the node x and the branch-parent bp x it also includes a branch 
information structure which contains the origination node of the 
branch x the total number of branches originating from x and the 
number of branches originating from x that are merged into a 
single representation by this branch information structure this 
number starts at intuitively when the number of merged branches 
equals the total number of originating branches the algorithm has 
reached the merge point for x in figure node e sends a utility 
propagation message to its branch-parent node d this message 
has dimensions for the domains of e and d and includes branch 
information with an origin of e total branches and merged 
branch 
as in the original dpop utility propagation phase an agent at 
leaf node x sends a utility propagation message to its parent in 
dcpop this message contains dimensions for the domains of p x 
and pp x if node x also has branch-parents then the utility 
propagation message also contains a dimension for the domain of x 
and will include a branch information structure in figure node 
e sends a utility propagation message to its parent node c this 
message has dimensions for the domains of e and c and includes 
branch information with an origin of e total branches and 
merged branch 
when a node y receives utility propagation messages from all of 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
its children and branch-children it merges any branches with the 
same origination node x the merged branch information structure 
accumulates the number of merged branches for x if the 
cumulative total number of merged branches equals the total number of 
branches then y is the merge point for x this means that the 
utility hypercubes present at y contain all information about the 
valuations for utility functions involving node x in addition to the 
typical elimination of the domain of y from the utility hypercubes 
we can now safely eliminate the domain of x from the utility 
hypercubes to illustrate this process we will examine what happens 
in the second phase for node b in figure 
in the second phase node b receives two utility propagation 
messages the first comes from node c and includes dimensions 
for domains e b and a it also has a branch information structure 
with origin of e total branches and merged branch the second 
comes from node d and includes dimensions for domains e and b 
it also has a branch information structure with origin of e total 
branches and merged branch node b then merges the branch 
information structures from both messages because they have the 
same origination node e since the number of merged branches 
originating from e is now and the total branches originating from 
e is node b now eliminates the dimensions for domain e node 
b also eliminates the dimension for its own domain leaving only 
information about domain a node b then sends a utility 
propagation message to node a containing only one dimension for the 
domain of a 
although not possible in dpop this method of utility 
propagation and dimension elimination may produce hypercubes at node y 
that do not share any domains in dcpop we do not join domain 
independent hypercubes but instead may send multiple hypercubes 
in the utility propagation message sent to the parent of y this lazy 
approach to joins helps to reduce message sizes 
 value propagation 
as in dpop value propagation begins when the agent at the root 
node z has received all messages from its children at this point 
the agent at node z chooses the assignment for its domain that has 
the best utility if z is the merge point for the branches of some 
node x z will also choose the assignment for the domain of x 
thus any node that is a merge point will choose assignments for 
a domain other than its own these assignments are then passed 
down the primary edge hierarchy if node x in the hierarchy has 
branch-parents then the value assignment message from p x will 
contain an assignment for the domain of x every node in the 
hierarchy adds any assignments it has chosen to the ones it received 
and passes the set of assignments to its children the algorithm is 
complete when all nodes have chosen or received an assignment for 
their domain 
 proof of correctness 
we will prove the correctness of dcpop by first noting that 
dcpop fully extends dpop and then examining the two cases for 
value assignment in dcpop given a traditional pseudotree as 
input the dcpop algorithm execution is identical to dpop using a 
traditional pseudotree arrangement no nodes have branch-parents 
or branch-children since all edges are either back-edges or tree 
edges thus the dcpop algorithm using a traditional pseudotree 
sends only utility propagation messages that contain domains 
belonging to the parent or pseudo-parents of a node since no node 
has any branch-parents no branches exist and thus no node serves 
as a merge point for any other node thus all value propagation 
assignments are chosen at the node of the assignment domain 
for dcpop execution with cross-edged pseudotrees some 
nodes serve as merge points we note that any node x that is not a 
merge point assigns its value exactly as in dpop the local utility 
hypercube at x contains domains for x p x pp x and bc x 
as in dpop the value assignment message received at x includes 
the values assigned to p x and pp x also since x is not a merge 
point all assignments to bc x must have been calculated at merge 
points higher in the tree and are in the value assignment message 
from p x thus after eliminating domains for which assignments 
are known only the domain of x is left the agent at node x can 
now correctly choose the assignment with maximum utility for its 
own domain 
if node x is a merge point for some branch-child y we know 
that x must be a node along the path from y to the root and from 
p y and all bp y to the root from the algorithm we know that 
y necessarily has all information from c y pc y and bc y 
since it waits for their messages node x has information about all 
nodes below it in the tree which would include y p y bp y 
and those pp y that are below x in the tree for any pp y above 
x in the tree x receives the assignment for the domain of pp y 
in the value assignment message from p x thus x has utility 
information about all of the utility functions of which y is a part 
by eliminating domains included in the value assignment message 
node x is left with a local utility hypercube with domains for x and 
y the agent at node x can now correctly choose the assignments 
with maximum utility for the domains of x and y 
 complexity analysis 
the first phase of dcpop sends one message to each p x 
pp x and bp x the second phase sends one value assignment 
message to each c x thus dcpop produces a linear number of 
messages with respect to the number of edges utility functions in 
the cross-edged pseudotree and the original dcop instance the 
actual complexity of dcpop depends on two additional 
measurements message size and computation size 
message size and computation size in dcpop depend on the 
number of overlapping branches as well as the number of 
overlapping back-edges it was shown in that the number of 
overlapping back-edges is equal to the induced width of the pseudotree in 
a poorly constructed cross-edged pseudotree the number of 
overlapping branches at node x can be as large as the total number 
of descendants of x thus the total message size in dcpop in a 
poorly constructed instance can be space-exponential in the total 
number of nodes in the graph however in practice a well 
constructed cross-edged pseudotree can achieve much better results 
later we address the issue of choosing well constructed 
crossedged pseudotrees from a set 
we introduce an additional measurement of the maximum 
sequential path cost through the algorithm this measurement 
directly relates to the maximum amount of parallelism achievable by 
the algorithm to take this measurement we first store the total 
computation size for each node during phase two and three this 
computation size represents the number of individual accesses to a 
value in a hypercube at each node for example a join between two 
domains of size costs two directed acyclic graphs 
 dag can then be drawn one with the utility propagation 
messages as edges and the phase two costs at nodes and the other with 
value assignment messages and the phase three costs at nodes the 
maximum sequential path cost is equal to the sum of the longest 
path on each dag from the root to any leaf node 
 heuristics 
in our assessment of complexity in dcpop we focused on the 
worst case possibly produced by the algorithm we acknowledge 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
algorithm dcpop algorithm 
 dcpop x d u 
each agent xi executes 
phase pseudotree creation 
 elect leader from all xj ∈ x 
 elected leader initiates pseudotree creation 
 afterwards xi knows p xi pp xi bp xi c xi bc xi 
and pc xi 
phase util message propagation 
 if bp xi then 
 branchxi ← bp xi 
 for all xk ∈bp xi do 
 utilxi xk ←compute utils xi xk 
 send message xk utilxi xk branchxi 
 if c xi i e xi is a leaf node then 
 utilxi p xi ← compute utils p xi pp xi 
for all pp xi 
 send message p xi 
utilxi p xi branchxi 
 send message pp xi empty util 
empty branch to all pp xi 
 activate util message handler 
phase value message propagation 
 activate value message handler 
end algorithm 
util message handler xk utilxk xi 
branchxk 
 store utilxk xi branchxk xi 
 if util messages from all children and branch children arrived 
then 
 for all bj ∈branch xi do 
 if bj is merged then 
 join all hypercubes where bj ∈util xi 
 eliminate bj from the joined hypercube 
 if p xi null that means xi is the root then 
 v i ← choose optimal null 
 send value xi v i to all c xi 
 else 
 utilxi p xi ← compute utils p xi 
pp xi 
 send message p xi utilxi p xi 
branchxi p xi 
value message handler valuexi p xi 
 add all xk ← v k ∈valuexi p xi to agent view 
 xi ← v i choose optimal agent view 
 send valuexl xi to all xl ∈c xi 
that in real world problems the generation of the pseudotree has 
a significant impact on the actual performance the problem of 
finding the best pseudotree for a given dcop instance is np-hard 
thus a heuristic is used for generation and the performance of the 
algorithm depends on the pseudotree found by the heuristic some 
previous research focused on finding heuristics to generate good 
pseudotrees while we have developed some heuristics that 
generate good cross-edged pseudotrees for use with dcpop our 
focus has been to use multiple heuristics and then select the best 
pseudotree from the generated pseudotrees 
we consider only heuristics that run in polynomial time with 
respect to the number of nodes in the original dcop instance the 
actual dcpop algorithm has worst case exponential complexity 
but we can calculate the maximum message size computation size 
and sequential path cost for a given cross-edged pseudotree in 
linear space-time complexity to do this we simply run the algorithm 
without attempting to calculate any of the local utility hypercubes 
or optimal value assignments instead messages include 
dimensional and branch information but no utility hypercubes 
after each heuristic completes its generation of a pseudotree we 
execute the measurement procedure and propagate the 
measurement information up to the chosen root in that pseudotree the 
root then broadcasts the total complexity for that heuristic to all 
nodes after all heuristics have had a chance to complete every 
node knows which heuristic produced the best pseudotree each 
node then proceeds to begin the dcpop algorithm using its 
knowledge of the pseudotree generated by the best heuristic 
the heuristics used to generate traditional pseudotrees perform 
a distributed dfs traversal the general distributed algorithm uses 
a token passing mechanism and a linear number of messages 
improved dfs based heuristics use a special procedure to choose the 
root node and also provide an ordering function over the neighbors 
of a node to determine the order of path recursion the dfs based 
heuristics used in our experiments come from the work done in 
 
 the best-first cross-edged pseudotree 
heuristic 
the heuristics used to generate cross-edged pseudotrees 
perform a best-first traversal a general distributed best-first 
algorithm for node expansion is presented in algorithm an 
evaluation function at each node provides the values that are used to 
determine the next best node to expand note that in this 
algorithm each node only exchanges its best value with its neighbors 
in our experiments we used several evaluation functions that took 
as arguments an ordered list of ancestors and a node which 
contains a list of neighbors with each neighbor s placement depth in 
the tree if it was placed from these we can calculate 
branchparents branch-children and unknown relationships for a potential 
node placement the best overall function calculated the value as 
ancestors− branchparents branchchildren with the 
number of unknown relationships being a tiebreak after completion 
each node has knowledge of its parent and ancestors so it can 
easily determine which connected nodes are pseudo-parents 
branchparents pseudo-children and branch-children 
the complexity of the best-first traversal depends on the 
complexity of the evaluation function assuming a complexity of o v 
for the evaluation function which is the case for our best 
overall function the best-first traversal is o v · e which is at worst 
o n 
 for each v ∈ v we perform a place operation and find the 
next node to place using the getbestneighbor operation the place 
operation is at most o v because of the sent messages 
finding the next node uses recursion and traverses only already placed 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
algorithm distributed best-first search algorithm 
root ← electedleader 
next root ∅ 
place node parent 
node parent ← parent 
node ancestors ← parent ancestors ∪ parent 
send placement message node node ancestors to all 
neighbors of node 
next current previous 
if current is not placed then 
place current previous 
next current ∅ 
else 
best ← getbestneighbor current previous 
if best ∅ then 
if previous ∅ then 
terminate all nodes are placed 
next previous ∅ 
else 
next best current 
getbestneighbor current previous 
best ← ∅ score ← 
for all n ∈ current neighbors do 
if n previous then 
if n is placed then 
nscore ← getbestneighbor n current 
else 
nscore ← evaluate current n 
if nscore score then 
score ← nscore 
best ← n 
return best score 
nodes so it has o v recursions each recursion performs a 
recursive getbestneighbor operation that traverses all placed nodes 
and their neighbors this operation is o v · e but results can 
be cached using only o v space at each node thus we have 
o v · v v v ·e o v 
·e if we are smart about evaluating 
local changes when each node receives placement messages from 
its neighbors and cache the results the getbestneighbor operation 
is only o e this increases the complexity of the place operation 
but for all placements the total complexity is only o v · e thus 
we have an overall complexity of o v ·e v · v e o v ·e 
 comparison of complexity in 
dpop and dcpop 
we have already shown that given the same input dcpop 
performs the same as dpop we also have shown that we can 
accurately predict performance of a given pseudotree in linear 
spacetime complexity if we use a constant number of heuristics to 
generate the set of pseudotrees we can choose the best pseudotree in 
linear space-time complexity we will now show that there exists 
a dcop instance for which a cross-edged pseudotree outperforms 
all possible traditional pseudotrees based on edge-traversal 
heuristics 
in figure a we have a dcop instance with six nodes this 
is a bipartite graph with each partition fully connected to the other 
 a b c 
figure a the dcop instance b a traditional pseudotree 
arrangement for the dcop instance c a cross-edged 
pseudotree arrangement for the dcop instance 
partition in figure b we see a traditional pseudotree 
arrangement for this dcop instance it is easy to see that any 
edgetraversal based heuristic cannot expand two nodes from the same 
partition in succession we also see that no node can have more 
than one child because any such arrangement would be an invalid 
pseudotree thus any traditional pseudotree arrangement for this 
dcop instance must take the form of figure b we can see that 
the back-edges f-b and f-a overlap node c node c also has a 
parent e and a back-edge with d using the original dpop 
algorithm or dcpop since they are identical in this case we find that 
the computation at node c involves five domains a b c d and 
e 
in contrast the cross-edged pseudotree arrangement in 
figure c requires only a maximum of four domains in any 
computation during dcpop since node a is the merge point for branches 
from both b and c we can see that each of the nodes d e and f 
have two overlapping branches in addition each of these nodes has 
node a as its parent using the dcpop algorithm we find that the 
computation at node d or e or f involves four domains a b c 
and d or e or f 
since no better traditional pseudotree arrangement can be 
created using an edge-traversal heuristic we have shown that dcpop 
can outperform dpop even if we use the optimal pseudotree found 
through edge-traversal we acknowledge that pseudotree 
arrangements that allow parent-child relationships without an actual 
constraint can solve the problem in figure a with maximum 
computation size of four domains however current heuristics used 
with dpop do not produce such pseudotrees and such a heuristic 
would be difficult to distribute since each node would require 
information about nodes with which it has no constraint also while we 
do not prove it here cross-edged pseudotrees can produce smaller 
message sizes than such pseudotrees even if the computation size 
is similar in practice since finding the best pseudotree 
arrangement is np-hard we find that heuristics that produce cross-edged 
pseudotrees often produce significantly smaller computation and 
message sizes 
 experimental results 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
existing performance metrics for dcop algorithms include the 
total number of messages synchronous clock cycles and message 
size we have already shown that the total number of messages is 
linear with respect to the number of constraints in the dcop 
instance we also introduced the maximum sequential path cost pc 
as a measurement of the maximum amount of parallelism 
achievable by the algorithm the maximum sequential path cost is equal 
to the sum of the computations performed on the longest path from 
the root to any leaf node we also include as metrics the 
maximum computation size in number of dimensions cd and 
maximum message size in number of dimensions md to analyze the 
relative complexity of a given dcop instance we find the 
minimum induced width iw of any traditional pseudotree produced 
by a heuristic for the original dpop 
 generic dcop instances 
for our initial tests we randomly generated two sets of problems 
with cases in each each problem was generated by 
assigning a random number picked from a range of constraints to each 
variable the generator then created binary constraints until each 
variable reached its maximum number of constraints the first set 
uses variables and the best dpop iw ranges from to with 
an average of the second set uses variables and the best 
dpop iw ranged from to with an average of since most 
of the problems in the second set were too complex to actually 
compute the solution we took measurements of the metrics using the 
techniques described earlier in section without actually solving 
the problem results are shown for the first set in table and for 
the second set in table 
for the two problem sets we split the cases into low density and 
high density categories low density cases consist of those 
problems that have a best dpop iw less than or equal to half of the 
total number of nodes e g iw ≤ for the node problems 
and iw ≤ for the node problems high density problems 
consist of the remainder of the problem sets 
in both table and table we have listed performance 
metrics for the original dpop algorithm the dcpop algorithm using 
only cross-edged pseudotrees dcpop-ce and the dcpop 
algorithm using traditional and cross-edged pseudotrees dcpop-all 
the pseudotrees used for dpop were generated using 
heuristics dfs dfs mcn dfs clique mcn dfs mcn dstb 
and dfs mcn bec these are all versions of the guided dfs 
traversal discussed in section the cross-edged pseudotrees used 
for dcpop-ce were generated using heuristics mcn lcn 
mcn a-b lcn a-b and lcsg a-b these are all versions of 
the best-first traversal discussed in section 
for both dpop and dcpop-ce we chose the best pseudotree 
produced by their respective heuristics for each problem in the 
set for dcpop-all we chose the best pseudotree produced by all 
 heuristics for each problem in the set for the cd and md 
metrics the value shown is the average number of dimensions for the 
pc metric the value shown is the natural logarithm of the 
maximum sequential path cost since the actual value grows 
exponentially with the complexity of the problem 
the final row in both tables is a measurement of improvement 
of dcpop-all over dpop for the cd and md metrics the value 
shown is a reduction in number of dimensions for the pc metric 
the value shown is a percentage reduction in the maximum 
sequential path cost dp op −dcp op 
dcp op 
 notice that 
dcpopall outperforms dpop on all metrics this logically follows from 
our earlier assertion that given the same input dcpop performs 
exactly the same as dpop thus given the choice between the 
pseudotrees produced by all heuristics dcpop-all will always 
outlow density high density 
algorithm cd md pc cd md pc 
dpop 
dcpop-ce 
dcpop-all 
improvement 
table node problems 
low density high density 
algorithm cd md pc cd md pc 
dpop 
dcpop-ce 
dcpop-all 
improvement 
table node problems 
figure computation dimension size 
figure message dimension size 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
figure path cost 
dcpop improvement 
ag mtg vars const iw cd md pc 
 - - 
 
 
 
 
 
table meeting scheduling problems 
perform dpop another trend we notice is that the improvement is 
greater for high density problems than low density problems we 
show this trend in greater detail in figures and notice 
how the improvement increases as the complexity of the problem 
increases 
 meeting scheduling problem 
in addition to our initial generic dcop tests we ran a series 
of tests on the meeting scheduling problem msp as described 
in the problem setup includes a number of people that are 
grouped into departments each person must attend a specified 
number of meetings meetings can be held within departments or 
among departments and can be assigned to one of eight time slots 
the msp maps to a dcop instance where each variable represents 
the time slot that a specific person will attend a specific meeting 
all variables that belong to the same person have mutual exclusion 
constraints placed so that the person cannot attend more than one 
meeting during the same time slot all variables that belong to the 
same meeting have equality constraints so that all of the 
participants choose the same time slot unary constraints are placed on 
each variable to account for a person s valuation of each meeting 
and time slot 
for our tests we generated sample problems for each 
combination of agents and meetings results are shown in table the 
values in the first five columns represent in left to right order the 
total number of agents the total number of meetings the total 
number of variables the average total number of constraints and the 
average minimum iw produced by a traditional pseudotree the 
last three columns show the same metrics we used for the generic 
dcop instances except this time we only show the improvements 
of dcpop-all over dpop performance is better on average for 
all msp instances but again we see larger improvements for more 
complex problem instances 
 conclusions and future work 
we presented a complete distributed algorithm that solves 
general dcop instances using cross-edged pseudotree arrangements 
our algorithm extends the dpop algorithm by adding additional 
utility propagation messages and introducing the concept of branch 
merging during the utility propagation phase our algorithm also 
allows value assignments to occur at higher level merge points 
for lower level nodes we have shown that dcpop fully extends 
dpop by performing the same operations given the same input 
we have also shown through some examples and experimental data 
that dcpop can achieve greater performance for some problem 
instances by extending the allowable input set to include cross-edged 
pseudotrees 
we placed particular emphasis on the role that edge-traversal 
heuristics play in the generation of pseudotrees we have shown 
that the performance penalty is minimal to generate multiple 
heuristics and that we can choose the best generated pseudotree 
in linear space-time complexity given the importance of a good 
pseudotree for performance future work will include new 
heuristics to find better pseudotrees future work will also include 
adapting existing dpop extensions that support different problem 
domains for use with dcpop 
 references 
 j liu and k p sycara exploiting problem structure for 
distributed constraint optimization in v lesser editor 
proceedings of the first international conference on 
multi-agent systems pages - san francisco ca 
 mit press 
 p j modi h jung m tambe w -m shen and s kulkarni 
a dynamic distributed constraint satisfaction approach to 
resource allocation lecture notes in computer science 
 - 
 p j modi w shen m tambe and m yokoo an 
asynchronous complete method for distributed constraint 
optimization in aamas 
 a petcu frodo a framework for open distributed 
constraint optimization technical report no 
 swiss federal institute of technology epfl 
lausanne switzerland http liawww epfl ch frodo 
 a petcu and b faltings a-dpop approximations in 
distributed optimization in poster in cp pages 
 - sitges spain october 
 a petcu and b faltings dpop a scalable method for 
multiagent constraint optimization in ijcai pages 
 - edinburgh scotland aug 
 a petcu b faltings and d parkes m-dpop faithful 
distributed implementation of efficient social choice 
problems in aamas pages - hakodate 
japan may 
 g ushakov solving meeting scheduling problems using 
distributed pseudotree-optimization procedure master s 
thesis ´ecole polytechnique f´ed´erale de lausanne 
 m yokoo e h durfee t ishida and k kuwabara 
distributed constraint satisfaction for formalizing distributed 
problem solving in international conference on distributed 
computing systems pages - 
 m yokoo e h durfee t ishida and k kuwabara the 
distributed constraint satisfaction problem formalization 
and algorithms knowledge and data engineering 
 - 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
