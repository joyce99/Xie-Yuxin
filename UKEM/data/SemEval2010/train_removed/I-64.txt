organizational self-design in semi-dynamic environments 
sachin kamboj 
 
and keith s decker 
department of computer and information sciences 
university of delaware 
newark de 
 kamboj decker  cis udel edu 
abstract 
organizations are an important basis for coordination in 
multiagent systems however there is no best way to organize and all 
ways of organizing are not equally effective attempting to 
optimize an organizational structure depends strongly on 
environmental features including problem characteristics available resources 
and agent capabilities if the environment is dynamic the 
environmental conditions or the problem task structure may change over 
time this precludes the use of static design-time generated 
organizational structures in such systems on the other hand for many 
real environments the problems are not totally unique either 
certain characteristics and conditions change slowly if at all and these 
can have an important effect in creating stable organizational 
structures 
organizational-self design osd has been proposed as an 
approach for constructing suitable organizational structures at 
runtime we extend the existing osd approach to include 
worthoriented domains model other resources in addition to only 
processor resources and build in robustness into the organization we 
then evaluate our approach against the contract-net approach and 
show that our osd agents perform better are more efficient and 
more flexible to changes in the environment 
categories and subject descriptors 
i distributed artificial intelligence multiagent systems 
general terms 
algorithms design performance experimentation 
 introduction 
in this paper we are primarily interested in the organizational 
design of a multiagent system - the roles enacted by the agents 
 primary author is a student 
the coordination between the roles and the number and assignment 
of roles and resources to the individual agents the organizational 
design is complicated by the fact that there is no best way to 
organize and all ways of organizing are not equally effective 
instead the optimal organizational structure depends both on the 
problem at hand and the environmental conditions under which the 
problem needs to be solved the environmental conditions may 
not be known a priori or may change over time which would 
preclude the use of a static organizational structure on the other hand 
all problem instances and environmental conditions are not always 
unique which would render inefficient the use of a new bespoke 
organizational structure for every problem instance 
organizational self-design osd has been proposed 
as an approach to designing organizations at run-time in which 
the agents are responsible for generating their own organizational 
structures we believe that osd is especially suited to the above 
scenario in which the environment is semi-dynamic as the agents 
can adapt to changes in the task structures and environmental 
conditions while still being able to generate relatively stable 
organizational structures that exploit the common characteristics across 
problem instances 
in our approach as in we define two operators for osd 
- agent spawning and composition - when an agent becomes 
overloaded it spawns off a new agent to handle part of its task 
load responsibility when an agent lies idle for an extended period 
of time it may decide to compose with another agent 
we use tæms as the underlying representation for our 
problem solving requests tæms task analysis environment 
modeling and simulation is a computational framework for 
representing and reasoning about complex task environments in which 
tasks problems are represented using extended hierarchical task 
structures the root node of the task structure represents the 
high-level goal that the agent is trying to achieve the sub-nodes of 
a node represent the subtasks and methods that make up the 
highlevel task the leaf nodes are at the lowest level of abstraction and 
represent executable methods - the primitive actions that the agents 
can perform the executable methods themselves may have 
multiple outcomes with different probabilities and different 
characteristics such as quality cost and duration tæms also allows 
various mechanisms for specifying subtask variations and alternatives 
i e each node in tæms is labeled with a characteristic 
accumulation function that describes how many or which subgoals or sets of 
subgoals need to be achieved in order to achieve a particular 
higherlevel goal tæms has been used to model many different 
problemsolving environments including distributed sensor networks 
information gathering hospital scheduling ems and military planning 
 
the main contributions of this paper are as follows 
 we extend existing osd approaches to use tæms as the 
underlying problem representation which allows us to model 
and use osd for worth-oriented domains this in turn 
allows us to reason about alternative task and role 
assignments that make different quality cost tradeoffs and generate 
different organizational structures and uncertainties in the 
execution of tasks 
 we model the use of resources other than only processor 
resources 
 we incorporate robustness into the organizational structures 
 related work 
the concept of osd is not new and has been around since 
the work of corkill and lesser on the dvmt system even 
though the concept was not fully developed by them more 
recently dignum et al have described osd in the context of the 
reorganization of agent societies and attempt to classify the various 
kinds of reorganization possible according to the the reason for 
reorganization the type of reorganization and who is responsible for 
the reorganization decision according to their scheme the type of 
reorganization done by our agents falls into the category of 
structural changes and the reorganization decision can be described as 
shared command 
our research primarily builds on the work done by gasser and 
ishida in which they use osd in the context of a 
production system in order to perform adaptive work allocation and load 
balancing in their approach they define two organizational 
primitives - composition and decomposition which are similar to our 
organizational primitives for agent spawning and composition the 
main difference between their work and our work is that we use 
tæms as the underlying representation for our problems which 
allows firstly the representation of a larger more general class of 
problems and secondly quantitative reasoning over task structures 
the latter also allows us to incorporate different design-to-criteria 
schedulers 
horling and lesser present a different top-down approach to 
osd that also uses tæms as the underlying representation 
however their approach assumes a fixed number of agents with 
designated and fixed roles osd is used in their work to change the 
interaction patterns between the agents and results in the agents 
using different subtasks or different resources to achieve their goals 
we also extend on the work done by sycara et al on agent 
cloning which is another approach to resource allocation and load 
balancing in this approach the authors present agent cloning as 
a possible response to agent overload - if an agent detects that it 
is overloaded and that there are spare unused resources in the 
system the agent clones itself and gives its clone some part of its 
task load hence agent cloning can be thought of as akin to agent 
spawning in our approach however the two approaches are 
different in that there is no specialization of the agents in the 
formerthe cloned agents are perfect replicas of the original agents and 
fulfill the same roles and responsibilities as the original agents in our 
approach on the other hand the spawned agents are specialized on 
a subpart of the spawning agent s task structure which is no longer 
the responsibility of the spawning agent hence our approach also 
deals with explicit organization formation and the coordination of 
the agents tasks which are not handled by their approach 
other approaches to osd include the work of so and durfee 
 who describe a top-down model of osd in the context of 
cooperative distributive problem solving cdps and barber and 
martin who describe an adaptive decision making framework 
in which agents are able to reorganize decision-making groups by 
dynamically changing who makes the decisions for a particular 
goal and who must carry out these decisions the latter work is 
primarily concerned with coordination decisions and can be used 
to complement our osd work which primarily deals with task and 
resource allocation 
 task and resource model 
to ground our discussion of osd we now formally describe 
our task and resource model in our model the primary input to 
the multi-agent system mas is an ordered set of problem 
solving requests or task instances p p p pn where each 
problem solving request pi can be represented using the tuple 
 ti ai di in this scheme ti is the underlying tæms task 
structure ai ∈ n 
is the arrival time and di ∈ n 
is the deadline 
of the ith 
task instance 
 the mas has no prior knowledge about 
the task ti before the arrival time ai in order for the mas to 
accrue quality the task ti must be completed before the deadline 
di 
furthermore every underlying task structure ti can be 
represented using the tuple t τ m q e r ρ c where 
 t is the set of tasks the tasks are non-leaf nodes in a 
tæms task structure and are used to denote goals that the 
agents must achieve tasks have a characteristic 
accumulation function see below and are themselves composed of 
other subtasks and or methods that need to be achieved in 
order to achieve the goal represented by that task formally 
each task tj can be represented using the pair qj sj where 
qj ∈ q and sj ⊂ t ∪ m for our convenience we 
define two functions subtasks task t → p t ∪ m and 
supertasks tæms node t ∪ m → p t that return 
the subtasks and supertasks of a tæms node respectively 
 
 τ ∈ t is the root of the task structure i e the highest level 
goal that the organization is trying to achieve the quality 
accrued on a problem is equal to the quality of task τ 
 m is the set executable methods i e m 
 m m mn where each method mk 
is represented using the outcome distribution 
 o p o p om pm in the pair ol pl 
ol is an outcome and pl is the probability that executing mk 
will result in the outcome ol furthermore each outcome 
ol is represented using the triple ql cl dl where ql is the 
quality distribution cl is the cost distribution and dl is the 
duration distribution of outcome ol each discrete 
distribution is itself a set of pairs n p n p nn pn 
where pi ∈ 
is the probability that the outcome will have 
a quality cost duration of nl ∈ n depending on the type of 
distribution and 
pm 
i pl 
 q is the set of quality characteristic accumulation functions 
 cafs the cafs determine how a task group accrues 
quality given the quality accrued by its subtasks methods for 
our research we use four cafs min max sum and 
exactly one see for formal definitions 
 e is the set of non-local effects again see for formal 
definitions 
 r is the set of resources 
 ρ is a mapping from an executable method and resource to 
the quantity of that resource needed by an agent to 
schedule execute that method that is ρ method resource 
m × r → n 
 
n is the set of natural numbers including zero and n 
is the set 
of positive natural numbers excluding zero 
 
p is the power set of set i e the set of all subsets of a set 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
 c is a mapping from a resource to the cost of that resource 
that is c resource r → n 
we also make the following set of assumptions in our research 
 the agents in the mas are drawn from the infinite set a 
 a a a that is we do not assume a fixed set of 
agents - instead agents are created spawned and destroyed 
 combined as needed 
 all problem solving requests have the same underlying task 
structure i e ∃t∀iti t where t is the task structure of 
the problem that the mas is trying to solve we believe that 
this assumption holds for many of the practical problems that 
we have in mind because tæms task structures are 
basically high-level plans for achieving some goal in which the 
steps required for achieving the goal-as well as the possible 
contingency situations-have been pre-computed offline and 
represented in the task structure because it represents many 
contingencies alternatives uncertain characteristics and 
runtime flexible choices the same underlying task structure 
can play out very differently across specific instances 
 all resources are exclusive i e only one agent may use a 
resource at any given time furthermore we assume that 
each agent has to own the set of resources that it 
needseven though the resource ownership can change during the 
evolution of the organization 
 all resources are non-consumable 
 organizational self design 
 agent roles and relationships 
the organizational structure is primarily composed of roles and 
the relationships between the roles one or more agents may enact 
a particular role and one or more roles must be enacted by every 
agent the roles may be thought of as the parts played by the agents 
enacting the roles in the solution to the problem and reflect the 
long-term commitments made by the agents in question to a certain 
course of action that includes task responsibility authority and 
mechanisms for coordination the relationships between the roles 
are the coordination relationships that exist between the subparts of 
a problem 
in our approach the organizational design is directly contingent 
on the task structure and the environmental conditions under which 
the problems need to be solved we define a role as a tæms 
subtree rooted at a particular node hence the set t ∪ m 
encompasses the space of all possible roles note by definition a role 
may consist of one or more other sub- roles as a particular tæms 
node may itself be made up of one or more subtrees hence we will 
use the terms role task node and task interchangeably 
we also differentiate between local and managed non-local 
roles local roles are roles that are the sole responsibility of a 
single agent that is the agent concerned is responsible for solving all 
the subproblems of the tree rooted at that node for such roles the 
agent concerned can do one or more subtasks solely at its 
discretion and without consultation with any other agent managed roles 
on the other hand must be coordinated between two or more agents 
as such roles will have two or more descendent local roles that are 
the responsibility of two or more separate agents any of the 
existing coordination mechanisms such as gpgp can be used to 
achieve this coordination 
formally if the function type agent tæms node a× t ∪ 
m → local managed unassigned returns the type of the 
responsibility of the agent towards the specified role then 
type a r local ⇐⇒ 
∀ri∈subtasks r type a ri local 
type a r managed ⇐⇒ 
 ∃a ∃r r ∈ subtasks r ∧ type a r managed ∨ 
 ∃a ∃a ∃r ∃r a a ∧ r r ∧ 
 r ∈ subtasks r ∧ r ∈ subtasks r ∧ 
 type a r local ∧ type a r local 
 organization formation and adaptation 
to form or adapt their organizational structure the agents use 
two organizational primitives agent spawning and composition 
these two primitives result in a change in the assignment of roles 
to the agents agent spawning is the generation of a new agent to 
handle a subset of the roles of the spawning agent agent 
composition on the other hand is orthogonal to agent spawning and 
involves the merging of two or more agents together - the 
combined agent is responsible for enacting all the roles of the agents 
being merged 
in order to participate in the formation and adaption of an 
organization the agents need to explicitly represent and reason about 
the role assignments hence as a part of its organizational 
knowledge each agent keeps a list of the local roles that it is enacting and 
the non-local roles that it is managing note that each agent only 
has limited organizational knowledge and is individually 
responsible for spawning off or combining with another agent as needed 
based on its estimate of its performance so far 
to see how the organizational primitives work we first describe 
four rules that can be thought of as the organizational invariants 
which will always hold before and after any organizational change 
 for a local role all the descendent nodes of that role will be 
local 
type a r local ⇒ 
∀ri∈subtasks r type a ri local 
 similarly for a managed non-local role all the ascendent 
nodes of that role will be managed 
type a r managed ⇒ 
∀ri∈supertasks r ∃ai ai ∈ a ∧ type ai ri managed 
 if two local roles that are enacted by two different agents 
share a common ancestor that ancestor will be a managed 
role 
 type a r local ∧ type a r local ∧ 
 a a ∧ r r ⇒ 
∀ri∈ supertasks r ∩supertasks r ∃ai ai ∈ a ∧ 
 type ai ri managed 
 if all the direct descendants of a role are local and the sole 
responsibility of a single agent that role will be a local role 
∃a∃r∀ri∈subtasks r a ∈ a ∧ r ∈ t ∪ m ∧ 
 type a ri local ⇒ 
 type a r local 
when a new agent is spawned the agent doing the spawning will 
assign one or more of its local roles to the newly spawned agent 
 algorithm to preserve invariant rules and the spawning 
agent will change the type of all the ascendent roles of the nodes 
assigned to the newly spawned agent from local to managed note 
that the spawning agent is only changing its local organizational 
knowledge and not the global organizational knowledge at the 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
same time the spawning agent is taking on the task of managing 
the previously local roles similarly the newly spawned agent will 
only know of its just assigned local roles 
when an agent the composing agent decides to compose with 
another agent the composed agent the organizational knowledge 
of the composing agent is merged with the organizational 
knowledge of the composed agent to do this the composed agent takes 
on the roles of all the local and managed tasks of the composing 
agent care is taken to preserve the organizational invariant rules 
and 
algorithm spawnagent spawningagent a → a 
 localroles ← r ⊆ t ∪ m type spawningagent 
r local 
 newagent ← createnewagent 
 newagentroles ← findrolesforspawnedagent 
 localroles 
 for role in newagentroles do 
 type newagent role ← local 
 type spawningagent role ← unassigned 
 preserveorganizationalinvariants 
 return newagent 
algorithm findrolesforspawnedagent 
 spawningagentroles t ∪ m → t ∪ m 
 r ← spawningagentroles 
 selectedroles ← nil 
 for roleset in p r − φ r do 
 if cost r roleset cost r selectedroles then 
 selectedroles ← roleset 
 return selectedroles 
algorithm getresourcecost roles t ∪ m → 
 m ← roles ∩ m 
 cost ← 
 for resource in r do 
 maxresourceusage ← 
 for method in m do 
 if ρ method resource maxresourceusage then 
 max ← ρ method resource 
 cost ← cost 
 c resource × maxresourceusage 
 return cost 
 role allocation during spawning 
one of the key questions that the agent doing the spawning needs 
to answer is - which of its local-roles should it assign to the newly 
spawned agent and which of its local roles should it keep to 
itself the onus of answering this question falls on the 
findrolesforspawnedagent function shown in algorithm above this 
function takes the set of local roles that are the responsibility of the 
spawning agent and returns a subset of those roles for allocation 
to the newly spawned agent this subset is selected based on the 
results of a cost function as is evident from line of the algorithm 
since the use of different cost functions will result in different 
organizational structures and since we have no a priori reason to believe 
that one cost function will out-perform the other we evaluated the 
performance of three different cost functions based on the 
following three different heuristics 
algorithm getexpectedduration roles t ∪ m → n 
 m ← roles ∩ m 
 exptduration ← 
 for outcome q c d outcomeprob in m do 
 exptoutcomeduration ← 
 for n p in d do 
 exptoutcomeduration ← n × p 
 exptduration ← exptduration 
 exptoutcomeduration × outcomeprob 
 return exptduration 
allocating top-most roles first this heuristic always breaks 
up at the top-most nodes first that is if the nodes of a task 
structure were numbered starting from the root in a breadth-first 
fashion then this heuristic would select the local-role of the spawning 
agent that had the lowest number and breakup that node by 
allocating one of its subtasks to the newly spawned agent we 
selected this heuristic because a it is the simplest to implement b 
fastest to run the role allocation can be done in constant time 
without the need of a search through the task structure and c it makes 
sense from a human-organizational perspective as this heuristic 
corresponds to dividing an organization along functional lines 
minimizing total resources this heuristic attempts to 
minimize the total cost of the resources needed by the agents in the 
organization to execute their roles if r be the local roles of the 
spawning agent and r be the subset of roles being evaluated for 
allocation to the newly spawned agent the cost function for this 
heuristic is given by cost r r ← getresourcecost r − 
r getresourcecost r 
balancing execution time this heuristic attempts to allocate 
roles in a way that tries to ensure that each agent has an equal 
amount of work to do for each potential role allocation this 
heuristic works by calculating the absolute value of the difference 
between the expected duration of its own roles after spawning and 
the expected duration of the roles of the newly spawned agent 
if this difference is close to zero then the both the agents have 
roughly the same amount of work to do formally if r be the 
local roles of the spawning agent and r be the subset of roles 
being evaluated for allocation to the newly spawned agent then 
the cost function for this heuristic is given by cost r r ← 
 getexpectedduration r−r −getexpectedduration r 
to evaluate these heuristics we ran a series of experiments that 
tested the performance of the resultant organization on randomly 
generated task structures the results are given in section 
 reasons for organizational change 
as organizational change is expensive requiring clock cycles 
allocation deallocation of resources etc we want a stable 
organizational structure that is suited to the task and environmental 
conditions at hand hence we wish to change the organizational 
structure only if the task structure and or environmental conditions 
change also to allow temporary changes to the environmental 
conditions to be overlooked we want the probability of an 
organizational change to be inversely proportional to the time since the last 
organizational change if this time is relatively short the agents are 
still adjusting to the changes in the environment - hence the 
probability of an agent initiating an organizational change should be 
high similarly if the time since the last organizational change is 
relatively large we wish to have a low probability of organizational 
change 
to allow this variation in probability of organizational change 
we use simulated annealing to determine the probability of 
keepthe sixth intl joint conf on autonomous agents and multi-agent systems aamas 
ing an existing organizational structure this probability is 
calculated using the annealing formula p e− δe 
kt where δe is the 
amount of overload underload t is the time since the last 
organizational change and k is a constant the mechanism of 
computing δe is different for agent spawning than for agent composition 
and is described below from this formula if t is large p or the 
probability of keeping the existing organizational structure is large 
note that the value of p is capped at a certain threshold in order to 
prevent the organization from being too sluggish in its reaction to 
environmental change 
to compute if agent spawning is necessary we use the annealing 
equation with δe 
α slack 
where α is a constant and slack is 
the difference between the total time available for completion of 
the outstanding tasks and the sum of the expected time required for 
completion of each task on the task queue also if the amount of 
slack is negative immediate agent spawning will occur without use 
of the annealing equation 
to calculate if agent composition is necessary we again use the 
simulated annealing equation however in this case δe β 
idle time where β is a constant and idle time is the amount 
of time for which the agent was idle if the agent has been sitting 
idle for a long period of time δe is large which implies that p 
the probability of keeping the existing organizational structure is 
low 
 organization and robustness 
there are two approaches commonly used to achieve robustness 
in multiagent systems 
 the survivalist approach which involves replicating 
domain agents in order to allow the replicas to take over should 
the original agents fail and 
 the citizen approach which involves the use of special 
monitoring agents called sentinel agents in order to detect 
agent failure and dynamically startup new agents in lieu of 
the failed ones 
the advantage of the survivalist approach is that recovery is 
relatively fast since the replicas are pre-existing in the organization 
and can take over as soon as a failure is detected the advantages 
of the citizen approach are that it requires fewer resources little 
modification to the existing organizational structure and 
coordination protocol and is simpler to implement 
both of these approaches can be applied to achieve robustness in 
our osd agents and it is not clear which approach would be better 
rather a thorough empirical evaluation of both approaches would 
be required in this paper we present the citizen approach as it has 
been shown by to have a better performance than the survivalist 
approach in the contract net protocol and leave the presentation 
and evaluation of the survivalist approach to a future paper 
to implement the citizen approach we designed special 
monitoring agents that periodically poll the domain agents by sending 
them are you alive messages that the agents must respond to if 
an agent fails it will not respond to such messages - the 
monitoring agents can then create a new agent and delegate the 
responsibilities of the dead agent to the new agent 
this delegation of responsibilities is non-trivial as the 
monitoring agents do not have access to the internal state of the domain 
agents which is itself composed of two components - the 
organizational knowledge and the task information the former consists 
of the information about the local and managerial roles of the agent 
while the latter is composed of the methods that are being 
scheduled and executed and the tasks that have been delegated to other 
agents this state information can only be deduced by monitoring 
and recording the messages being sent and received by the domain 
agents for example in order to deduce the organizational 
knowledge the monitoring agents need to keep a track of the spawn and 
compose messages sent by the agents in order to trigger the 
spawning and composition operations respectively the deduction 
process is particularly complicated in the case of the task information 
as the monitoring agents do not have access to the private 
schedules of the domain agents the details are beyond the scope of this 
paper 
 evaluation 
to evaluate our approach we ran a series of experiments that 
simulated the operation of both the osd agents and the contract 
net agents on various task structures with varied arrival rates and 
deadlines at the start of each experiment a random tæms task 
structure was generated with a specified depth and branching 
factor during the course of the experiment a series of task instances 
 problems arrive at the organization and must be completed by the 
agents before their specified deadlines 
to directly compare the osd approach with the contract net 
approach each experiment was repeated several times - using osd 
agents on the first run and a different number of contract net agents 
on each subsequent run we were careful to use the same task 
structure task arrival times task deadlines and random numbers for each 
of these trials 
we divided the experiments into two groups experiments in 
which the environment was static fixed task arrival rates and 
deadlines and experiments in which the environment was dynamic 
 varying arrival rates and or deadlines 
the two graphs in figure show the average performance of the 
osd organization against the contract net organizations with 
 and agents the results shown are the averages of running 
 experiments of those experiments had a static environment 
with a fixed task arrival time of cycles and a deadline window of 
 cycles the remaining experiments had a varying task arrival 
rate - the task arrival rate was changed from cycles to cycles 
and back to cycles after every tasks in all the experiments 
the task structures were randomly generated with a maximum depth 
of and a maximum branching factor of the runtime of all the 
experiments was cycles 
we tested several hypotheses relating to the comparative 
performance of our osd approach using the wilcoxon matched-pair 
signed-rank tests matched-pair signifies that we are comparing 
the performance of each system on precisely the same randomized 
task set within each separate experiment the tested hypothesis are 
the osd organization requires fewer agents to complete an 
equal or larger number of tasks when compared to the 
contract net organization to test this hypothesis we tested the 
stronger null hypothesis that states that the contract net agents 
complete more tasks this null hypothesis is rejected for all contract 
net organizations with less than agents static p 
dynamic p for large contract net organizations the number 
of tasks completed is statistically equivalent to the number 
completed by the osd agents however the number of agents used by 
the osd organization is smaller agents in the static case and 
 agents in the dynamic case versus contract net agents 
 
thus the original hypothesis that osd requires fewer agents to 
 
these values should not be construed as an indication of the 
scalability of our approach we have tested our approach on 
organizations with more than agents which is significantly greater than 
the number of agents needed for the kind of applications that we 
have in mind i e web service choreography efficient dynamic use 
of grid computing distributed information gathering etc 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
figure graph comparing the average performance of the 
osd organization with the contract net organizations with 
 and agents the error bars show the standard 
deviations 
complete an equal or larger number of tasks is upheld 
the osd organizations achieve an equal or greater average 
quality than the contract net organizations the null 
hypothesis is that the contract net agents achieve a greater average quality 
we can reject the null hypothesis for contract net organizations with 
less than agents static p dynamic p for 
larger contract net organizations the average quality is statistically 
equivalent to that achieved by osd 
the osd agents have a lower average response time as 
compared to the contract net agents the null hypothesis that osd 
has the same or higher response time is rejected for all contract net 
organizations static p dynamic p 
the osd agents send less messages than the contract net 
agents the null hypothesis that osd sends the same or more 
messages is rejected for all contract net organizations p 
in all cases except contract net agents in a static environment 
where p 
hence as demonstrated by the above tests our agents perform 
better than the contract net agents as they complete a larger number 
of tasks achieve a greater quality and also have a lower response 
time and communication overhead these results make intuitive 
sense given our goals for the osd approach we expected the osd 
organizations to have a faster average response time and to send 
less messages because the agents in the osd organization are not 
wasting time and messages sending bid requests and replying to 
bids the quality gained on the tasks is directly dependent on the 
criteria heuristic bet tf mr rand 
number of agents 
no-org-changes 
total-messages-sent 
resource-cost 
tasks-completed 
average-quality 
average-response-time 
average-runtime 
average-turnaround-time 
table the number of times that each heuristic performed 
the best or statistically equivalent to the best for each of the 
performance criteria heuristic key bet is balancing 
execution time tf is topmost first mr is minimizing resources and 
rand is a random allocation strategy in which every tæms 
node has a uniform probability of being selected for allocation 
number of tasks completed hence the more the number of tasks 
completed the greater average quality the results of testing the 
first hypothesis were slightly more surprising it appears that due 
to the inherent inefficiency of the contract net protocol in bidding 
for each and every task instance a greater number of agents are 
needed to complete an equal number of tasks 
next we evaluated the performance of the three heuristics for 
allocating tasks some preliminary experiments that are not reported 
here due to space constraints demonstrated the lack of a clear 
winner amongst the three heuristics for most of the performance 
criteria that we evaluated we suspected this to be the case because 
different heuristics are better for different task structures and 
environmental conditions and since each experiment starts with a different 
random task structure we couldn t find one allocation strategy that 
always dominated the other for all the performance criteria 
to determine which heuristic performs the best given a set of 
task structures environmental conditions and performance criteria 
we performed a series of experiments that were controlled using 
the following five variables 
 the depth of the task structure was varied from to 
 the branching factor was varied from to 
 the probability of any given task node having a min caf 
was varied from to in increments of the 
probability of any node having a sum caf was in turn modified 
to ensure that the probabilities add up to 
 
 the arrival rate from to cycles in increments of 
 the deadline slack from to in increments of 
each experiment was repeated times with a new task 
structure being generated each time - these experiments formed an 
experimental set hence all the experiments in an experimental set 
had the same values for the exogenous variables that were used to 
control the experiment note that a static environment was used in 
each of these experiments as we wanted to see the performance of 
the arrival rate and deadline slack on each of the three heuristics 
also the results of any experiment in which the osd organization 
consisted of a single agent ware culled from the results similarly 
 
since our preliminary analysis led is to believe that the number 
of max and exactly one cafs in a task structure have a 
minimal effect on the performance of the allocation strategies being 
evaluated we set the probabilities of the max and exactly one 
cafs to in order to reduce the combinatorial explosion of the full 
factorial experimental design 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
experiments in which the generated task structures were 
unsatisfiable given the deadline constraints were removed from the final 
results if any experimental set had more than experiments thus 
removed the whole set was ignored for performing the evaluation 
the final evaluation was done on experimental sets 
we tested the potential of these three heuristics on the following 
performance criteria 
 the average number of agents used 
 the total number of organizational changes 
 the total messages sent by all the agents 
 the total resource cost of the organization 
 the number of tasks completed 
 the average quality accrued the average quality is defined 
as the total quality accrued during the experimental run 
divided by the sum of the number of tasks completed and the 
number of tasks failed 
 the average response time of the organization the response 
time of a task is defined as the difference between the time 
at which any agent in the organization starts working on 
the task the start time and the time at which the task was 
generated the generation time hence the response time 
is equivalent to the wait time for tasks that are never 
attempted started the response time is set at final runtime 
minus the generation time 
 the average runtime of the tasks attempted by the 
organization this time is defined as the difference between the time 
at which the task completed or failed and the start time for 
tasks that were never stated this time is set to zero 
 the turnaround time is defined as the sum of the response 
time and runtime of a task 
except for the number of tasks completed and the average 
quality accrued lower values for the various performance criteria 
indicate better performance again we ran the wilcoxon matched-pair 
signed-rank tests on the experiments in each of the experimental 
sets the null hypothesis in each case was that there is no 
difference between the pair of heuristics for the performance criteria 
under consideration we were interested in the cases in which we 
could reject the null hypothesis with confidence p 
we noted the number of times that a heuristic performed the best 
or was in a group that performed statistically better than the rest 
these counts are given in tables and 
the number of experimental sets in which each heuristic 
performed the best or statistically equivalent to the best is shown in 
table the breakup of these numbers into the number of times 
that each heuristic performed better than all the other heuristics and 
 the number of times each heuristic was statistically equivalent 
to another group of heuristics all of which performed the best is 
shown in table both of these tables allow us to glean important 
information about the performance of the three heuristics 
particularly interesting were the following results 
 whereas balancing execution time bet used the 
lowest number of agents in largest number of experimental sets 
 in most of these cases experimental sets it was 
statistically equivalent to topmost first tf when these 
two heuristics didn t perform equally there was an almost 
even split between the number of experimental sets in which 
one outperformed the other 
we believe this was the case because bet always bifurcates 
the agents into two agents that have a more or less equal task 
load this often results in organizations that have an even 
figure graph demonstrating the robustness of the citizen 
approach the baseline shows the number of tasks completed 
in the absence of any failure 
number of agents - none of which are small 
enough to 
combine into a larger agent with tf on the other hand a 
large agent can successively spawn off smaller agents until it 
and the spawned agents are small enough to complete their 
tasks before the deadlines - this often results in 
organizations with an odd number of agents that is less than those 
used by bet 
 as expected bet achieved the lowest number of 
organizational changes in the largest number of experimental sets in 
fact it was over ten times as good as its second best 
competitor tf this shows that if the agents are conscientious 
in their initial task allocation there is a lesser need for 
organizational change later on especially for static environments 
 a particularly interesting yet easily explainable result was 
that of the average response time we found that the 
minimizing resources mr heuristic performed the best when it 
came to minimizing the average response time this can be 
explained by the fact the mr heuristic is extremely greedy 
and prefers to spawn off small agents that have a tiny 
resource footprint so as to minimize the total increase in the 
resource cost to the organization at the time of spawning 
whereas most of these small agents might compose with 
other agents over time the presence of a single small agent 
is sufficient to reduce the response time 
in fact the mr heuristic is not the most effective heuristic 
when it comes to minimizing the resource-cost of the 
organization - in fact it only outperforms a random task resource 
allocation we believe this is in part due to the greedy 
nature of this heuristic and in part because of the fact that all 
spawning and composition operations only use local 
information we believe that using some non-local information 
about the resource allocation might help in making better 
decisions something that we plan to look at in the future 
finally we evaluated the performance of the citizens approach to 
robustness as applied to our osd mechanism figure as 
expected as the probability of failure increases the number of agents 
failing during a run also increases this results in a slight decrease 
in the number of tasks completed which can be explained by the 
fact that whenever an agent fails its looses whatever work it was 
doing at the time the newly created agent that fills in for the failed 
 
for this discussion small agents are agents that have a low 
expected duration for their local roles as calculated by algorithm 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
criteria heuristic bet tf mr rand bet tf bet rand mr rand tf mr bet tf mr all 
number of agents 
no-org-changes 
total-messages-sent 
resource-cost 
tasks-completed 
average-quality 
average-response-time 
average-runtime 
average-turnaround-time 
table table showing the number of times that each individual heuristic performed the best and the number of times that a certain 
group of statistically equivalent heuristics performed the best only the more interesting heuristic groupings are shown all shows 
the number of experimental sets in which there was no statistical difference between the three heuristics and a random allocation 
strategy 
one must redo the work thus wasting precious time which might 
not be available close to a deadline 
as a part of our future research we wish to firstly evaluate the 
survivalist approach to robustness the survivalist approach might 
actually be better than the citizen approach for higher 
probabilities of agent failure as the replicated agents may be processing the 
task structures in parallel and can take over the moment the 
original agents fail - thus saving time around tight deadlines also 
we strongly believe that the optimal organizational structure may 
vary depending on the probability of failure and the desired level 
of robustness for example one way of achieving a higher level 
of robustness in the survivalist approach given a large numbers of 
agent failures would be to relax the task deadlines however such 
a relaxation would result in the system using fewer agents in order 
to conserve resources which in turn would have a detrimental 
effect on the robustness therefore towards this end we have begun 
exploring the robustness properties of task structures and the ways 
in which the organizational design can be modified to take such 
properties into account 
 conclusion 
in this paper we have presented a run-time approach to 
organization in which the agents use organizational self-design to come up 
with a suitable organizational structure we have also evaluated the 
performance of the organizations generated by the agents following 
our approach with the bespoke organization formation that takes 
place in the contract net protocol and have demonstrated that our 
approach is better than the contract net approach as evident by the 
larger number of tasks completed larger quality achieved and lower 
response time finally we tested the performance of three different 
resource allocation heuristics on various performance metrics and 
also evaluated the robustness of our approach 
 references 
 k s barber and c e martin dynamic reorganization of 
decision-making groups in agents pages - 
new york ny usa 
 k m carley and l gasser computational organization 
theory in g wiess editor multiagent systems a modern 
approach to distributed artificial intelligence pages 
 - mit press 
 w chen and k s decker the analysis of coordination in 
an information system application - emergency medical 
services in lecture notes in computer science lncs 
number pages - springer-verlag may 
 d corkill and v lesser the use of meta-level control for 
coordination in a distributed problem solving network 
proceedings of the eighth international joint conference on 
artificial intelligence pages - august 
 k s decker environment centered analysis and design of 
coordination mechanisms ph d thesis dept of comp 
science university of massachusetts amherst may 
 k s decker and j li coordinating mutually exclusive 
resources using gpgp autonomous agents and multi-agent 
systems - 
 c dellarocas and m klein an experimental evaluation of 
domain-independent fault handling services in open 
multi-agent systems proceedings of the international 
conference on multi-agent systems icmas- july 
 
 v dignum f dignum and l sonenberg towards dynamic 
reorganization of agent societies in proceedings of ceas 
workshop on coordination in emergent agent societies at 
ecai pages - valencia spain september 
 b horling b benyo and v lesser using self-diagnosis to 
adapt organizational structures in agents pages 
 - new york ny usa acm press 
 t ishida l gasser and m yokoo organization self-design 
of distributed production systems ieee transactions on 
knowledge and data engineering - 
 v r lesser et al evolution of the gpgp tæms 
domain-independent coordination framework autonomous 
agents and multi-agent systems - - 
 o marin p sens j briot and z guessoum towards 
adaptive fault tolerance for distributed multi-agent systems 
proceedings of ersads may 
 o shehory k sycara et al agent cloning an approach to 
agent mobility and resource allocation ieee 
communications magazine - 
 y so and e durfee an organizational self-design model for 
organizational change in aaai- workshop on ai and 
theories of groups and organizations pages - 
washington d c july 
 t wagner coordination decision support assistants 
 coordinators technical report - baa 
 t wagner and v lesser design-to-criteria scheduling 
real-time agent control proc of aaai spring 
symposium on real-time autonomous systems - 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
