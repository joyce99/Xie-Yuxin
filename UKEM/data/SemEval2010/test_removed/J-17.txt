truthful mechanism design for multi-dimensional 
scheduling via cycle monotonicity 
ron lavi 
industrial engineering and management 
the technion - israel institute of technology 
ronlavi ie technion ac il 
chaitanya swamy 
combinatorics and optimization 
university of waterloo 
cswamy math uwaterloo ca 
abstract 
we consider the problem of makespan minimization on m 
unrelated machines in the context of algorithmic mechanism 
design where the machines are the strategic players this is 
a multidimensional scheduling domain and the only known 
positive results for makespan minimization in such a domain 
are o m -approximation truthful mechanisms we 
study a well-motivated special case of this problem where 
the processing time of a job on each machine may either 
be low or high and the low and high values are public 
and job-dependent this preserves the 
multidimensionality of the domain and generalizes the restricted-machines 
 i e pj ∞ setting in scheduling we give a general 
technique to convert any c-approximation algorithm to a 
 capproximation truthful-in-expectation mechanism this is 
one of the few known results that shows how to export 
approximation algorithms for a multidimensional problem into 
truthful mechanisms in a black-box fashion when the low 
and high values are the same for all jobs we devise a 
deterministic -approximation truthful mechanism these are 
the first truthful mechanisms with non-trivial performance 
guarantees for a multidimensional scheduling domain 
our constructions are novel in two respects first we 
do not utilize or rely on explicit price definitions to prove 
truthfulness instead we design algorithms that satisfy 
cycle monotonicity cycle monotonicity is a necessary 
and sufficient condition for truthfulness is a generalization 
of value monotonicity for multidimensional domains 
however whereas value monotonicity has been used extensively 
and successfully to design truthful mechanisms in 
singledimensional domains ours is the first work that leverages 
cycle monotonicity in the multidimensional setting second 
our randomized mechanisms are obtained by first 
constructing a fractional truthful mechanism for a fractional 
relaxation of the problem and then converting it into a 
truthfulin-expectation mechanism this builds upon a technique 
of and shows the usefulness of fractional mechanisms 
in truthful mechanism design 
categories and subject descriptors 
f analysis of algorithms and problem 
complexity j social and behavioral sciences economics 
general terms 
algorithms economics theory 
 introduction 
mechanism design studies algorithmic constructions 
under the presence of strategic players who hold the inputs 
to the algorithm algorithmic mechanism design has 
focused mainly on settings were the social planner or designer 
wishes to maximize the social welfare or equivalently 
minimize social cost or on auction settings where 
revenuemaximization is the main goal alternative optimization 
goals such as those that incorporate fairness criteria which 
have been investigated algorithmically and in social choice 
theory have received very little or no attention 
in this paper we consider such an alternative goal in the 
context of machine scheduling namely makespan 
minimization there are n jobs or tasks that need to be assigned to 
m machines where each job has to be assigned to exactly 
one machine assigning a job j to a machine i incurs a load 
 cost of pij ≥ on machine i and the load of a machine is 
the sum of the loads incurred due to the jobs assigned to it 
the goal is to schedule the jobs so as to minimize the 
maximum load of a machine which is termed the makespan of the 
schedule makespan minimization is a common objective in 
scheduling environments and has been well studied 
algorithmically in both the computer science and operations 
research communities see e g the survey following 
the work of nisan and ronen we consider each machine 
to be a strategic player or agent who privately knows its own 
processing time for each job and may misrepresent these 
values in order to decrease its load which is its incurred 
cost hence we approach the problem via mechanism 
design the social designer who holds the set of jobs to be 
assigned needs to specify in addition to a schedule suitable 
payments to the players in order to incentivize them to 
reveal their true processing times such a mechanism is called 
a truthful mechanism the makespan-minimization 
objective is quite different from the classic goal of social-welfare 
maximization where one wants to maximize the total 
welfare or minimize the total cost of all players instead it 
 
corresponds to maximizing the minimum welfare and the 
notion of max-min fairness and appears to be a much harder 
problem from the viewpoint of mechanism design in 
particular the celebrated vcg family of mechanisms 
does not apply here and we need to devise new techniques 
the possibility of constructing a truthful mechanism for 
makespan minimization is strongly related to assumptions 
on the players processing times in particular the 
dimensionality of the domain nisan and ronen considered the 
setting of unrelated machines where the pij values may be 
arbitrary this is a multidimensional domain since a player s 
private value is its entire vector of processing times pij j 
very few positive results are known for multidimensional 
domains in general and the only positive results known for 
multidimensional scheduling are o m -approximation 
truthful mechanisms we emphasize that regardless of 
computational considerations even the existence of a 
truthful mechanism with a significantly better than m 
approximation ratio is not known for any such scheduling domain 
on the negative side showed that no truthful 
deterministic mechanism can achieve approximation ratio better 
than and strengthened this lower bound to m for two 
specific classes of deterministic mechanisms recently 
extended this lower bound to randomized mechanisms and 
improved the deterministic lower bound 
in stark contrast with the above state of affairs much 
stronger and many more positive results are known for a 
special case of the unrelated machines problem namely the 
setting of related machines here we have pij pj si for 
every i j where pj is public knowledge and the speed si 
is the only private parameter of machine i this 
assumption makes the domain of players types single-dimensional 
truthfulness in such domains is equivalent to a convenient 
value-monotonicity condition which appears to make 
it significantly easier to design truthful mechanisms in such 
domains archer and tardos first considered the related 
machines setting and gave a randomized -approximation 
truthful-in-expectation mechanism the gap between the 
single-dimensional and multidimensional domains is perhaps 
best exemplified by the fact that showed that there 
exists a truthful mechanism that always outputs an optimal 
schedule recall that in the multidimensional unrelated 
machines setting it is impossible to obtain a truthful 
mechanism with approximation ratio better than various 
follow-up results have strengthened the notion 
of truthfulness and or improved the approximation ratio 
such difficulties in moving from the single-dimensional to 
the multidimensional setting also arise in other mechanism 
design settings e g combinatorial auctions thus in 
addition to the specific importance of scheduling in strategic 
environments ideas from multidimensional scheduling may 
also have a bearing in the more general context of truthful 
mechanism design for multidimensional domains 
in this paper we consider the makespan-minimization 
problem for a special case of unrelated machines where 
the processing time of a job is either low or high on 
each machine more precisely in our setting pij ∈ lj hj 
for every i j where the lj hj values are publicly known 
 lj ≡low hj ≡high we call this model the 
jobdependent two-values case this model generalizes the 
classic restricted machines setting where pij ∈ lj ∞ which 
has been well-studied algorithmically a special case of our 
model is when lj l and hj h for all jobs j which we 
denote simply as the two-values scheduling model both 
of our domains are multidimensional since the machines are 
unrelated one job may be low on one machine and high on 
the other while another job may follow the opposite 
pattern thus the private information of each machine is a 
vector specifying which jobs are low and high on it thus 
they retain the core property underlying the hardness of 
truthful mechanism design for unrelated machines and by 
studying these special settings we hope to gain some insights 
that will be useful for tackling the general problem 
our results and techniques we present various 
positive results for our multidimensional scheduling domains 
our first result is a general method to convert any 
capproximation algorithm for the job-dependent two values 
setting into a c-approximation truthful-in-expectation 
mechanism this is one of the very few known results that use 
an approximation algorithm in a black-box fashion to obtain 
a truthful mechanism for a multidimensional problem our 
result implies that there exists a -approximation 
truthfulin-expectation mechanism for the lj-hj setting 
interestingly the proof of truthfulness is not based on supplying 
explicit prices and our construction does not necessarily yield 
efficiently-computable prices but the allocation rule is 
efficiently computable our second result applies to the 
twovalues setting lj l hj h for which we improve both 
the approximation ratio and strengthen the notion of 
truthfulness we obtain a deterministic -approximation truthful 
mechanism along with prices for this problem these are 
the first truthful mechanisms with non-trivial performance 
guarantees for a multidimensional scheduling domain 
complementing this we observe that even this seemingly simple 
setting does not admit truthful mechanisms that return an 
optimal schedule unlike in the case of related machines 
by exploiting the multidimensionality of the domain we 
prove that no truthful deterministic mechanism can obtain 
an approximation ratio better than to the makespan 
 irrespective of computational considerations 
the main technique and one of the novelties 
underlying our constructions and proofs is that we do not rely on 
explicit price specifications in order to prove the 
truthfulness of our mechanisms instead we exploit certain 
algorithmic monotonicity conditions that characterize 
truthfulness to first design an implementable algorithm i e an 
algorithm for which prices ensuring truthfulness exist and then 
find these prices by further delving into the proof of 
implementability this kind of analysis has been the method 
of choice in the design of truthful mechanisms for 
singledimensional domains where value-monotonicity yields a 
convenient characterization enabling one to concentrate on the 
algorithmic side of the problem see e g 
but for multidimensional domains almost all positive 
results have relied on explicit price specifications in order to 
prove truthfulness an exception is the work on unknown 
single-minded players in combinatorial auctions a 
fact that yet again shows the gap in our understanding of 
multidimensional vs single-dimensional domains 
our work is the first to leverage monotonicity conditions 
for truthful mechanism design in arbitrary domains the 
monotonicity condition we use which is sometimes called 
cycle monotonicity was first proposed by rochet see 
also it is a generalization of value-monotonicity and 
completely characterizes truthfulness in every domain our 
methods and analyses demonstrate the potential benefits 
 
of this characterization and show that cycle monotonicity 
can be effectively utilized to devise truthful mechanisms for 
multidimensional domains consider for example our first 
result showing that any c-approximation algorithm can be 
exported to a c-approximation truthful-in-expectation 
mechanism at the level of generality of an arbitrary 
approximation algorithm it seems unlikely that one would be 
able to come up with prices to prove truthfulness of the 
constructed mechanism but cycle monotonicity does allow 
us to prove such a statement in fact some such condition 
based only on the underlying algorithm and not on the 
prices seems necessary to prove such a general statement 
the method for converting approximation algorithms into 
truthful mechanisms involves another novel idea our 
randomized mechanism is obtained by first constructing a 
truthful mechanism that returns a fractional schedule moving 
to a fractional domain allows us to plug-in truthfulness 
into the approximation algorithm in a rather simple 
fashion while losing a factor of in the approximation ratio 
we then use a suitable randomized rounding procedure to 
convert the fractional assignment into a random integral 
assignment for this we use a recent rounding procedure 
of kumar et al that is tailored for unrelated-machine 
scheduling this preserves truthfulness but we lose another 
additive factor equal to the approximation ratio our 
construction uses and extends some observations of lavi and 
swamy and further demonstrates the benefits of 
fractional mechanisms in truthful mechanism design 
related work nisan and ronen first considered the 
makespan-minimization problem for unrelated machines they 
gave an m-approximation positive result and proved various 
lower bounds recently mu alem and schapira proved 
a lower bound of on the approximation ratio achievable 
by truthful-in-expectation mechanisms and christodoulou 
koutsoupias and vidali proved a 
√ 
 -lower bound 
for deterministic truthful mechanisms archer and tardos 
first considered the related-machines problem and gave a 
 -approximation truthful-in-expectation mechanism this 
been improved in to a -approximation 
randomized mechanism an fptas for any fixed number of 
machines given by andelman azar and sorani and a 
 -approximation deterministic mechanism by kov´acs 
the algorithmic problem i e without requiring 
truthfulness of makespan-minimization on unrelated machines 
is well understood and various -approximation algorithms 
are known lenstra shmoys and tardos gave the first 
such algorithm shmoys and tardos later gave a 
 approximation algorithm for the generalized assignment 
problem a generalization where there is a cost cij for assigning 
a job j to a machine i and the goal is to minimize the cost 
subject to a bound on the makespan recently kumar 
marathe parthasarathy and srinivasan gave a 
randomized rounding algorithm that yields the same bounds we 
use their procedure in our randomized mechanism 
the characterization of truthfulness for arbitrary domains 
in terms of cycle monotonicity seems to have been first 
observed by rochet see also gui et al this 
generalizes the value-monotonicity condition for single-dimensional 
domains which was given by myerson and rediscovered 
by as mentioned earlier this condition has been 
exploited numerous times to obtain truthful mechanisms for 
single-dimensional domains for convex 
domains i e each players set of private values is convex it 
is known that cycle monotonicity is implied by a simpler 
condition called weak monotonicity but even 
this simpler condition has not found much application in 
truthful mechanism design for multidimensional problems 
objectives other than social-welfare maximization and 
revenue maximization have received very little attention in 
mechanism design in the context of combinatorial auctions the 
problems of maximizing the minimum value received by a 
player and computing an envy-minimizing allocation have 
been studied briefly lavi mu alem and nisan showed 
that the former objective cannot be implemented truthfully 
bezakova and dani gave a -approximation mechanism 
for two players with additive valuations lipton et al 
showed that the latter objective cannot be implemented 
truthfully these lower bounds were strengthened in 
 preliminaries 
 the scheduling domain 
in our scheduling problem we are given n jobs and m 
machines and each job must be assigned to exactly one 
machine in the unrelated-machines setting each machine i 
is characterized by a vector of processing times pij j where 
pij ∈ r≥ ∪ ∞ denotes i s processing time for job j with 
the value ∞ specifying that i cannot process j we consider 
two special cases of this problem 
 the job-dependent two-values case where pij ∈ 
 lj hj for every i j with lj ≤ hj and the values 
lj hj are known this generalizes the classic 
scheduling model of restricted machines where hj ∞ 
 the two-values case which is a special case of above 
where lj l and hj h for all jobs j i e pij ∈ 
 l h for every i j 
we say that a job j is low on machine i if pij lj and high 
if pij hj we will use the terms schedule and assignment 
interchangeably we represent a deterministic schedule by a 
vector x xij i j where xij is if job j is assigned to 
machine i thus we have xij ∈ for every i j 
p 
i xij 
for every job j we will also consider randomized algorithms 
and algorithms that return a fractional assignment in both 
these settings we will again specify an assignment by a 
vector x xij i j with 
p 
j xij but now xij ∈ for 
every i j for a randomized algorithm xij is simply the 
probability that j is assigned to i thus x is a convex 
combination of integer assignments 
we denote the load of machine i under a given 
assignment by li 
p 
j xijpij and the makespan of a schedule is 
defined as the maximum load on any machine i e maxi li 
the goal in the makespan-minimization problem is to 
assign the jobs to the machines so as to minimize the makespan 
of the schedule 
 mechanism design 
we consider the makespan-minimization problem in the 
above scheduling domains in the context of mechanism 
design mechanism design studies strategic settings where the 
social designer needs to ensure the cooperation of the 
different entities involved in the algorithmic procedure following 
the work of nisan and ronen we consider the machines 
to be the strategic players or agents the social designer 
holds the set of jobs that need to be assigned but does 
 
not know the true processing times of these jobs on the 
different machines each machine is a selfish entity that 
privately knows its own processing time for each job on a 
machine incurs a cost to the machine equal to the true 
processing time of the job on the machine and a machine may 
choose to misrepresent its vector of processing times which 
are private in order to decrease its cost 
we consider direct-revelation mechanisms each machine 
reports its possibly false vector of processing times the 
mechanism then computes a schedule and hands out 
payments to the players i e machines to compensate them 
for the cost they incur in processing their assigned jobs a 
 direct-revelation mechanism thus consists of a tuple x p 
x specifies the schedule and p pi specifies the 
payments handed out to the machines where both x and the pis 
are functions of the reported processing times p pij i j 
the mechanism s goal is to compute a schedule that has 
near-optimal makespan with respect to the true processing 
times a machine i is however only interested in maximizing 
its own utility pi − li where li is its load under the output 
assignment and may declare false processing times if this 
could increase its utility the mechanism must therefore 
incentivize the machines players to truthfully reveal their 
processing times via the payments this is made precise 
using the notion of dominant-strategy truthfulness 
definition truthfulness a scheduling mechanism 
is truthful if for every machine i every vector of processing 
times of the other machines p−i every true processing-time 
vector p 
i and any other vector p 
i of machine i we have 
p 
i − 
x 
j 
x 
ijp 
ij ≥ p 
i − 
x 
j 
x 
ijp 
ij 
where x 
 p 
 and x 
 p 
 are respectively the schedule and 
payments when the other machines declare p−i and machine 
i declares p 
i and p 
i i e x 
 x p 
i p−i p 
i pi p 
i p−i 
and x 
 x p 
i p−i p 
i pi p 
i p−i 
to put it in words in a truthful mechanism no machine can 
improve its utility by declaring a false processing time no 
matter what the other machines declare 
we will also consider fractional mechanisms that return 
a fractional assignment and randomized mechanisms that 
are allowed to toss coins and where the assignment and the 
payments may be random variables the notion of 
truthfulness for a fractional mechanism is the same as in 
definition where x 
 x 
are now fractional assignments 
for a randomized mechanism we will consider the notion 
of truthfulness in expectation which means that a 
machine player maximizes her expected utility by declaring 
her true processing-time vector inequality also defines 
truthfulness-in-expectation for a randomized mechanism where 
p 
i p 
i now denote the expected payments made to player i 
x 
 x 
are the fractional assignments denoting the 
randomized algorithm s schedule i e xk 
ij is the probability that j 
is assigned to i in the schedule output for pk 
i p−i 
for our two scheduling domains the informational 
assumption is that the values lj hj are publicly known the 
private information of a machine is which jobs have value 
lj or l and which ones have value hj or h on it we 
emphasize that both of our domains are multidimensional 
since each machine i needs to specify a vector saying which 
jobs are low and high on it 
 cycle monotonicity 
although truthfulness is defined in terms of payments 
it turns out that truthfulness actually boils down to a 
certain algorithmic condition of monotonicity this seems to 
have been first observed for multidimensional domains by 
rochet in and has been used successfully in 
algorithmic mechanism design several times but for 
singledimensional domains however for multidimensional 
domains the monotonicity condition is more involved and there 
has been no success in employing it in the design of 
truthful mechanisms most positive results for multidimensional 
domains have relied on explicit price specifications in order 
to prove truthfulness one of the main contributions of this 
paper is to demonstrate that the monotonicity condition for 
multidimensional settings which is sometimes called cycle 
monotonicity can indeed be effectively utilized to devise 
truthful mechanisms we include a brief exposition on it for 
completeness the exposition here is largely based on 
cycle monotonicity is best described in the abstract social 
choice setting there is a finite set a of alternatives there 
are m players and each player has a private type 
 valuation function v a → r where vi a should be interpreted 
as i s value for alternative a in the scheduling domain a 
represents all the possible assignments of jobs to machines 
and vi a is the negative of i s load in the schedule a let 
vi denote the set of all possible types of player i a 
mechanism is a tuple f pi where f v × · · · × vm → a 
is the algorithm for choosing the alternative and pi 
v × · · · × vm → a is the price charged to player i in the 
scheduling setting the mechanism pays the players which 
corresponds to negative prices the mechanism is 
truthful if for every i every v−i ∈ v−i 
q 
i i vi and any 
vi vi ∈ vi we have vi a − pi vi v−i ≥ vi b − pi vi v−i 
where a f vi v−i and b f vi v−i a basic question 
that arises is given an algorithm f v × · · · × vm → a do 
there exist prices that will make the resulting mechanism 
truthful it is well known see e g that the price pi 
can only depend on the alternative chosen and the others 
declarations that is we may write pi v−i × a → r thus 
truthfulness implies that for every i every v−i ∈ v−i and 
any vi vi ∈ vi with f vi v−i a and f vi v−i b we 
have vi a − pi a v−i ≥ vi b − pi b v−i 
now fix a player i and fix the declarations v−i of the 
others we seek an assignment to the variables pa a∈a 
such that vi a − vi b ≥ pa − pb for every a b ∈ a and vi ∈ 
vi with f vi v−i a strictly speaking we should use 
a f vi v−i instead of a here define δa b inf vi a − 
vi b vi ∈ vi f vi v−i a we can now rephrase the 
above price-assignment problem we seek an assignment to 
the variables pa a∈a such that 
pa − pb ≤ δa b ∀a b ∈ a 
this is easily solved by looking at the allocation graph and 
applying a standard basic result of graph theory 
definition gui et al the allocation graph of 
f is a directed weighted graph g a e where e a × a 
and the weight of an edge b → a for any a b ∈ a is δa b 
theorem there exists a feasible assignment to iff 
the allocation graph has no negative-length cycles 
furthermore if all cycles are non-negative a feasible assignment is 
 
obtained as follows fix an arbitrary node a 
∈ a and set pa 
to be the length of the shortest path from a 
to a 
this leads to the following definition which is another way 
of phrasing the condition that the allocation graph have no 
negative cycles 
definition cycle monotonicity a social choice 
function f satisfies cycle monotonicity if for every player i every 
v−i ∈ v−i every integer k and every v 
i vk 
i ∈ vi 
kx 
k 
h 
vk 
i ak − vk 
i ak 
i 
≥ 
where ak f vk 
i v−i for ≤ k ≤ k and ak a 
corollary there exist prices p such that the 
mechanism f p is truthful iff f satisfies cycle monotonicity 
we now consider our specific scheduling domain fix a 
player i p−i and any p 
i pk 
i let x pk 
i p−i xk 
for 
 ≤ k ≤ k and let xk 
 x 
 pk 
 p 
 xk 
could 
be a -assignment or a fractional assignment we have 
vk 
i xk 
 − 
p 
j xk 
ijpk 
ij so cycle monotonicity translates to 
pk 
k 
ˆ 
− 
p 
j xk 
ijpk 
ij 
p 
j xk 
ij pk 
ij 
˜ 
≥ rearranging we get 
kx 
k 
x 
j 
xk 
ij 
` 
pk 
ij − pk 
ij 
´ 
≥ 
thus reduces our mechanism design problem to a 
concrete algorithmic problem for most of this paper we 
will consequently ignore any strategic considerations and 
focus on designing an approximation algorithm for minimizing 
makespan that satisfies 
 a general technique to obtain 
randomized mechanisms 
in this section we consider the case of job-dependent lj 
hj values with lj ≤ hj which generalizes the 
classical restricted-machines model where hj ∞ we show 
the power of randomization by providing a general 
technique that converts any c-approximation algorithm into a 
 c-approximation truthful-in-expectation mechanism this 
is one of the few results that shows how to export 
approximation algorithms for a multidimensional problem into truthful 
mechanisms when the algorithm is given as a black box 
our construction and proof are simple and based on two 
ideas first as outlined above we prove truthfulness using 
cycle monotonicity it seems unlikely that for an arbitrary 
approximation algorithm given only as a black box one 
would be able to come up with payments in order to prove 
truthfulness but cycle-monotonicity allows us to prove 
precisely this second we obtain our randomized mechanism 
by a first moving to a fractional domain and 
constructing a fractional truthful mechanism that is allowed to return 
fractional assignments then b using a rounding procedure 
to express the fractional schedule as a convex combination 
of integer schedules this builds upon a theme introduced 
by lavi and swamy namely that of using fractional 
mechanisms to obtain truthful-in-expectation mechanisms 
 
it is not clear if theorem and hence this statement 
hold if a is not finite 
we should point out however that one cannot simply plug 
in the results of their results hold for 
social-welfaremaximization problems and rely on using vcg to obtain 
a fractional truthful mechanism vcg however does not 
apply to makespan minimization and in our case even the 
existence of a near-optimal fractional truthful mechanism is 
not known we use the following result adapted from 
lemma lavi and swamy let m x p be 
a fractional truthful mechanism let a be a randomized 
rounding algorithm that given a fractional assignment x 
outputs a random assignment x such that e 
ˆ 
xij 
˜ 
 xij for 
all i j then there exist payments p such that the 
mechanism m a p is truthful in expectation furthermore 
if m is individually rational then m is individually rational 
for every realization of coin tosses 
let opt p denote the optimal makespan over integer 
schedules for instance p as our first step we take a 
capproximation algorithm and convert it to a c-approximation 
fractional truthful mechanism this conversion works even 
when the approximation algorithm returns only a fractional 
schedule satisfying certain properties of makespan at most 
c · opt p for every instance p we prove truthfulness by 
showing that the fractional algorithm satisfies cycle 
monotonicity notice that the alternative-set of our fractional 
mechanism is finite although the set of all fractional 
assignments is infinite its cardinality is at most that of the 
inputdomain which is at most mn 
in the two-value case thus 
we can apply corollary here to convert this fractional 
truthful mechanism into a randomized truthful mechanism 
we need a randomized rounding procedure satisfying the 
requirements of lemma fortunately such a procedure is 
already provided by kumar marathe parthasarathy and 
srinivasan 
lemma kumar et al given a fractional 
assignment x and a processing time vector p there exists a 
randomized rounding procedure that yields a random 
assignment x such that 
 for any i j e 
ˆ 
xij 
˜ 
 xij 
 for any i 
p 
j xijpij 
p 
j xijpij max j xij ∈ pij 
with probability 
property will be used to obtain truthfulness in 
expectation and property will allow us to prove an approximation 
guarantee we first show that any algorithm that returns 
a fractional assignment having certain properties satisfies 
cycle monotonicity 
lemma let a be an algorithm that for any input p 
outputs a fractional assignment x such that if pij hj 
then xij ≤ m and if pij lj then xij ≥ m then a 
satisfies cycle-monotonicity 
proof fix a player i and the vector of processing times 
of the other players p−i we need to prove that is 
pk 
k 
p 
j xk 
ij 
` 
pk 
ij − pk 
ij 
´ 
≥ for every p 
i pk 
i where 
index k k is taken to be k we will show that for 
every job j 
pk 
k xk 
ij 
` 
pk 
ij − pk 
ij 
´ 
≥ 
if pk 
ij is the same for all k either always lj or always hj 
then the above inequality clearly holds otherwise we can 
 
divide the indices k into maximal segments where 
a maximal segment is a maximal set of consecutive indices 
k k k − k where k ≡ such that pk 
ij 
hj ≥ pk 
ij ≥ · · · ≥ pk 
ij lj this follows because there 
must be some k such that pk 
ij hj pk− 
ij lj we take 
k k and then keep including indices in this segment till 
we reach a k such that pk 
ij lj and pk 
ij hj we set 
k k and then start a new maximal segment with index 
k note that k k and k k − we now 
have a subset of indices and we can continue recursively so 
all indices are included in some maximal segment we will 
show that for every such maximal segment k k k p 
k − ≤k k xk 
ij 
` 
pk 
ij − pk 
ij 
´ 
≥ adding this for each 
segment yields the desired inequality 
so now focus on a maximal segment k k k − 
 k thus there is some k 
such that for k ≤ k k 
 we 
have pk 
ij hj and for k 
≤ k ≤ k we have pk 
ij lj now 
the left hand side of the above inequality for this segment is 
simply xk 
ij lj −hj xk 
ij hj −lj ≥ since xk 
ij ≤ 
m 
≤ xk 
ij 
as pk 
ij hj and pk 
ij lj 
we now describe how to use a c-approximation algorithm 
to obtain an algorithm satisfying the property in lemma 
for simplicity first suppose that the approximation 
algorithm returns an integral schedule the idea is to simply 
spread this schedule we take each job j assigned to a 
high machine and assign it to an extent m on all machines 
for each job j assigned to a low machine say i we assign 
 m-fraction of it to the other machines where it is low and 
assign its remaining fraction which is at least m to i 
the resulting assignment clearly satisfies the desired 
properties also observe that the load on any machine has at most 
increased by 
m 
· load on other machines ≤ makespan and 
hence the makespan has at most doubled this spreading 
out can also be done if the initial schedule is fractional we 
now describe the algorithm precisely 
algorithm let a be any algorithm that on any input p 
outputs a possibly fractional assignment x such that xij 
implies that pij ≤ t where t is the makespan of x in 
particular note that any algorithm that returns an integral 
assignment has these properties our algorithm which we 
call a returns the following assignment xf 
 initialize xf 
ij 
 for all i j for every i j 
 if pij hj set xf 
ij 
p 
i pi j hj 
xi j m 
 if pij lj set xf 
ij xij 
p 
i i pi j lj 
 xi j −xij m 
p 
i pi j hj 
xi j m 
theorem suppose algorithm a satisfies the conditions 
in algorithm and returns a makespan of at most c·opt p 
for every p then the algorithm a constructed above is a 
 c-approximation cycle-monotone fractional algorithm 
moreover if xf 
ij on input p then pij ≤ c · opt p 
proof first note that xf 
is a valid assignment for 
every job j 
p 
i xf 
ij 
p 
i xij 
p 
i i i pij pi j lj 
 xi j − 
xij m 
p 
i xij we also have that if pij hj 
then xf 
ij 
p 
i pi j hj 
xi j m ≤ m if pij lj then 
xf 
ij xij − m 
p 
i i xi j m where i i 
pi j lj ≤ m − so xf 
ij ≥ 
p 
i xi j m ≥ m thus by 
lemma a satisfies cycle monotonicity 
the total load on any machine i under xf 
is at mostp 
j pij hj 
p 
i pi j hj 
hj· 
xi j 
m 
 
p 
j pij lj 
lj 
` 
xij 
p 
i i 
xi j 
m 
´ 
 
which is at most 
p 
j pijxij 
p 
i i 
p 
j pi jxi j m ≤ c · 
opt p finally if xf 
ij and pij lj then pij ≤ 
opt p if pij hj then for some i possibly i with 
pi j hj we have xi j so by assumption pi j hj 
pij ≤ c · opt p 
theorem combined with lemmas and gives a 
 c-approximation truthful-in-expectation mechanism the 
computation of payments will depend on the actual 
approximation algorithm used section does however give an 
explicit procedure to compute payments ensuring 
truthfulness though perhaps not in polynomial-time 
theorem the procedure in algorithm converts any 
c-approximation fractional algorithm into a c-approximation 
truthful-in-expectation mechanism 
taking a in algorithm to be the algorithm that returns 
an lp-optimum assignment satisfying the required 
conditions see we obtain a -approximation mechanism 
corollary there is a truthful-in-expectation mechanism 
with approximation ratio for the lj-hj setting 
 a deterministic mechanism for 
the two-values case 
we now present a deterministic -approximation truthful 
mechanism for the case where pij ∈ l h for all i j in 
the sequel we will often say that j is assigned to a 
lowmachine to denote that j is assigned to a machine i where 
pij l we will call a job j a low job of machine i if 
pij l the low-load of i is the load on i due to its low jobs 
i e 
p 
j pij l xijpij 
as in section our goal is to obtain an approximation 
algorithm that satisfies cycle monotonicity we first obtain 
a simplification of condition for our two-values l h 
scheduling domain proposition that will be convenient 
to work with we describe our algorithm in section 
in section we bound its approximation guarantee and 
prove that it satisfies cycle-monotonicity in section 
we compute explicit payments giving a truthful mechanism 
finally in section we show that no deterministic 
mechanism can achieve the optimum makespan define 
nk 
h 
˛ 
˛ j xk 
ij pk 
ij l pij h 
˛ 
˛ 
nk 
l 
˛ 
˛ j xk 
ij pk 
ij h pij l 
˛ 
˛ 
then 
p 
j xk 
ij pk 
ij − pk 
ij nk k 
h − nk k 
l h − l 
plugging this into and dividing by h − l we get the 
following 
proposition cycle monotonicity in the two-values 
scheduling domain is equivalent to the condition that for every 
player i every p−i every integer k and every p 
i pk 
i 
kx 
k 
` 
nk k 
h − nk k 
l 
´ 
≥ 
 
 acycle-monotone approximation algorithm 
we now describe an algorithm that satisfies condition 
and achieves a -approximation we will assume that l h 
are integers which is without loss of generality 
a core component of our algorithm will be a procedure 
that takes an integer load threshold t and computes an 
integer partial assignment x of jobs to machines such that a 
a job is only assigned to a low machine b the load on any 
machine is at most t and c the number of jobs assigned is 
maximized such an assignment can be computed by solving 
a max-flow problem we construct a directed bipartite graph 
with a node for every job j and every machine i and an edge 
 j i of infinite capacity if pij l we also add a source 
node s with edges s j having capacity and sink node t 
with edges i t having capacity t l clearly any integer 
flow in this network corresponds to a valid integer partial 
assignment x of makespan at most t where xij iff there 
is a flow of on the edge from j to i we will therefore use 
the terms assignment and flow interchangeably moreover 
there is always an integral max-flow since all capacities are 
integers we will often refer to such a max-flow as the 
max-flow for p t 
we need one additional concept before describing the 
algorithm there could potentially be many max-flows and 
we will be interested in the most balanced ones which we 
formally define as follows fix some max-flow let ni 
p t be 
the amount of flow on edge i t or equivalently the number 
of jobs assigned to i in the corresponding schedule and let 
np t be the total size of the max-flow i e np t 
p 
i ni 
p t 
for any t ≤ t define ni 
p t t min ni 
p t t that is we 
truncate the flow assignment on i so that the total load 
on i is at most t define np t t 
p 
i ni 
p t t we define 
a prefix-maximal flow or assignment for t as follows 
definition prefix-maximal flow a flow for the above 
network with threshold t is prefix-maximal if for every 
integer t ≤ t we have np t t np t 
that is in a prefix-maximal flow for p t if we truncate 
the flow at some t ≤ t we are left with a max-flow for 
 p t an elementary fact about flows is that if an 
assignment flow x is not a maximum flow for p t then there 
must be an augmenting path p s j i jk ik t in 
the residual graph that allows us to increase the size of the 
flow the interpretation is that in the current assignment 
j is unassigned xi j which is denoted by the 
forward edges j i and xi j which is denoted by 
the reverse edges i j augmenting x using p changes 
the assignment so that each j is assigned to i in the new 
assignment which increases the value of the flow by a 
simple augmenting path does not decrease the load of any 
machine thus one can argue that a prefix-maximal flow for 
a threshold t always exists we first compute a max-flow for 
threshold use simple augmenting paths to augment it to a 
max-flow for threshold and repeat each time augmenting 
the max-flow for the previous threshold t to a max-flow for 
threshold t using simple augmenting paths 
algorithm given a vector of processing times p 
construct an assignment of jobs to machines as follows 
 compute t 
 p min 
˘ 
t ≥ h t multiple of l 
np t · l n − np t · h ≤ m · t 
¯ 
 
note that np t ·l n−np t ·h −m·t is a decreasing 
function of t so t 
 p can be computed in polynomial 
time via binary search 
 compute a prefix-maximal flow for threshold t 
 p 
and the corresponding partial assignment i e j is 
assigned to i iff there is unit of flow on edge j i 
 assign the remaining jobs i e the jobs unassigned in 
the flow-phase in a greedy manner as follows 
consider these jobs in an arbitrary order and assign each 
job to the machine with the current lowest load where 
the load includes the jobs assigned in the flow-phase 
our algorithm needs to compute a prefix-maximal 
assignment for the threshold t 
 p the proof showing the 
existence of a prefix-maximal flow only yields a 
pseudopolynomial time algorithm for computing it but notice that the 
max-flow remains the same for any t ≥ t n · l so 
a prefix-maximal flow for t is also prefix-maximal for any 
t ≥ t thus we only need to compute a prefix-maximal 
flow for t min t 
 p t this can be be done in 
polynomial time by using the iterative-augmenting-paths 
algorithm in the existence proof to compute iteratively the 
maxflow for the polynomially many multiples of l up to and 
including t 
theorem one can efficiently compute payments that 
when combined with algorithm yield a deterministic 
 approximation truthful mechanism for the two-values 
scheduling domain 
 analysis 
let opt p denote the optimal makespan for p we now 
prove that algorithm is a -approximation algorithm that 
satisfies cycle monotonicity this will then allow us to 
compute payments in section and prove theorem 
 proof of approximation 
claim if opt p h the makespan is at most opt p 
proof if opt p h it must be that the optimal 
schedule assigns all jobs to low machines so np opt p n 
thus we have t 
 p l · h 
l 
 furthermore since we 
compute a prefix-maximal flow for threshold t 
 p we have 
np t p opt p np opt p n which implies that the 
load on each machine is at most opt p so in this case 
the makespan is at most and hence exactly opt p 
claim if opt p ≥ h then t 
 p ≤ l · opt p 
l 
≤ 
opt p l 
proof let nopt p be the number of jobs assigned to 
low machines in an optimum schedule the total load on all 
machines is exactly nopt p · l n − nopt p · h and is 
at most m · opt p since every machine has load at most 
opt p so taking t l · opt p 
l 
≥ h since np t ≥ 
nopt p we have that np t ·l n−np t ·h ≤ m·t hence 
t 
 p the smallest such t is at most l · opt p 
l 
 
claim each job assigned in step of the algorithm is 
assigned to a high machine 
 
proof suppose j is assigned to machine i in step if 
pij l then we must have ni 
p t p t 
 p otherwise we 
could have assigned j to i in step to obtain a flow of larger 
value so at the point just before j is assigned in step 
the load of each machine must be at least t 
 p hence 
the total load after j is assigned is at least m · t 
 p l 
m · t 
 p but the total load is also at most np t p · l 
 n − np t p · h ≤ m · t 
 p yielding a contradiction 
lemma the above algorithm returns a schedule with 
makespan at most opt p max 
˘ 
l h − 
m 
 
¯ 
≤ ·opt p 
proof if opt p h then by claim we are done 
so suppose opt p ≥ h by claim we know that 
t 
 p ≤ opt p l if there are no unassigned jobs after 
step of the algorithm then the makespan is at most t 
 p 
and we are done so assume that there are some unassigned 
jobs after step we will show that the makespan after step 
 is at most t h 
` 
 − 
m 
´ 
where t min 
˘ 
t 
 p opt p 
¯ 
 
suppose the claim is false let i be the machine with the 
maximum load so li t h 
` 
 − 
m 
´ 
 let j be the last job 
assigned to i in step and consider the point just before 
it is assigned to i so li t − h m at this point also 
since j is assigned to i by our greedy rule the load on all 
the other machines must be at least li so the total load 
after j is assigned is at least h m · li m · t since 
pij h by claim also for any assignment of jobs to 
machines in step the total load is at most np t p · l 
 n − np t p · h since there are np t p jobs assigned to 
low machines therefore we must have m · t np t p · 
l n − np t p · h but we will argue that m · t ≥ 
np t p ·l n−np t p ·h which yields a contradiction 
if t t 
 p this follows from the definition of t 
 p 
if t opt p then letting nopt p denote the number of 
jobs assigned to low machines in an optimum schedule we 
have np t p ≥ nopt p so np t p ·l n−np t p ·h ≤ 
nopt p ·l n−nopt p ·h this is exactly the total load 
in an optimum schedule which is at most m · opt p 
 proof of cycle monotonicity 
lemma consider any two instances p pi p−i and 
p pi p−i where pi ≥ pi i e pij ≥ pij ∀j if t is a 
threshold such that np t np t then every maximum flow 
x for p t must assign all jobs j such that pij l 
proof let gp denote the residual graph for p t and 
flow x suppose by contradiction that there exists a job j 
with pij l that is unassigned by x since pi ≥ pi all 
edges j i that are present in the network for p t are 
also present in the network for p t thus x is a valid 
flow for p t but it is not a max-flow since np t np t 
so there exists an augmenting path p in the residual graph 
for p t and flow x observe that node i must be included 
in p otherwise p would also be an augmenting path in the 
residual graph gp contradicting the fact that x is a 
maxflow in particular this implies that there is a path p ⊂ p 
from i to the sink t let p i j i jk ik t all 
the edges of p are also present as edges in gp - all reverse 
edges i j are present since such an edge implies that 
xi j 
 all forward edges j i are present since i i 
so pi j pi j l and xi j 
 but then there is 
an augmenting path j 
 i j i jk ik t in gp which 
contradicts the maximality of x 
let l denote the all-low processing time vector define 
tl 
i p−i t 
 l p−i since we are focusing on machine i 
and p−i is fixed throughout we abbreviate tl 
i p−i to tl 
 
also let pl 
 l p−i note that t 
 p ≥ tl 
for every 
instance p pi p−i 
corollary let p pi p−i be any instance and let x be 
any prefix-maximal flow for p t 
 p then the low-load 
on machine i is at most tl 
 
proof let t 
 t 
 p if t 
 tl 
 then this is clearly 
true otherwise consider the assignment x truncated at tl 
 
since x is prefix-maximal we know that this constitutes a 
max-flow for p tl 
 also np t l npl t l because t 
 
tl 
 so by lemma this truncated flow must assign all 
the low jobs of i hence there cannot be a job j with pij l 
that is assigned to i after the tl 
-threshold since then j 
would not be assigned by this truncated flow thus the 
low-load of i is at most tl 
 
using these properties we will prove the following key 
inequality for any p 
 p−i p 
i and p 
 p−i p 
i 
np t l ≥ np t l − n 
h n 
l 
where n 
h and n 
l are as defined in and 
respectively notice that this immediately implies cycle 
monotonicity since if we take p 
 pk 
and p 
 pk 
 then 
implies that npk t l ≥ npk t l − nk k 
h nk k 
l summing 
this over all k k gives 
lemma if t 
 p 
 tl 
 then holds 
proof let t 
 t 
 p 
 and t 
 t 
 p 
 take the 
prefix-maximal flow x 
for p 
 t 
 truncate it at tl 
 and 
remove all the jobs from this assignment that are counted in 
n 
h that is all jobs j such that x 
ij p 
ij l p 
ij h 
denote this flow by x observe that x is a valid flow for 
 p 
 tl 
 and the size of this flow is exactly np t t l −n 
h 
np t l −n 
h also none of the jobs that are counted in n 
l 
are assigned by x since each such job j is high on i in p 
 
since t 
 tl 
 we must have np t l npl t l so if we 
augment x to a max-flow for p 
 tl 
 then by lemma 
 with p pl 
and p p 
 all the jobs corresponding to 
n 
l must be assigned in this max-flow thus the size of 
this max-flow is at least size of x n 
l that is np t l ≥ 
np t l − n 
h n 
l as claimed 
lemma suppose t 
 p 
 tl 
 then holds 
proof again let t 
 t 
 p 
 tl 
and t 
 t 
 p 
 
let x 
 x 
be the complete assignment i e the assignment 
after both steps and computed by our algorithm for 
p 
 p 
respectively let s j x 
ij and p 
ij l and 
s j x 
ij and p 
ij l therefore s s − 
n 
h n 
l and s ni 
p t ni 
p t t l by corollary 
let t s · l we consider two cases 
suppose first that t ≤ tl 
 consider the following flow 
for p 
 tl 
 assign to every machine other than i the 
lowassignment of x 
truncated at tl 
 and assign the jobs in s 
to machine i this is a valid flow for p 
 tl 
 since the load 
on i is t ≤ tl 
 its size is equal to 
p 
i i ni 
p t t l s 
np t t l −n 
h n 
l np t l −n 
h n 
l the size of the 
max-flow for p 
 tl 
 is no smaller and the claim follows 
 
now suppose t tl 
 since s · l ≤ tl 
 by 
corollary it follows that n 
l n 
h ≥ let ˆt t − l ≥ 
tl 
since t tl 
are both multiples of l let m np t − 
n 
h n 
l s 
p 
i i ni 
p t we first show that 
m · ˆt m · l n − m · h 
let n be the number of jobs assigned to machine i in x 
 
the load on machine i is s ·l n − s ·h ≥ s ·l−n 
l · 
l n− s ·h which is at least s ·l ˆt since n 
l ≤ n− 
 s thus we get the inequality s ·l n − s ·h ˆt 
now consider the point in the execution of the algorithm 
on instance p 
just before the last high job is assigned to i 
in step there must be such a job since n 
l the 
load on i at this point is s · l n − s − · h which is 
least s · l − l ˆt by a similar argument as above by 
the greedy property every i i also has at least this load 
at this point so 
p 
j p 
i jx 
i j ≥ ˆt adding these inequalities 
for all i i and the earlier inequality for i we get that 
 s · l n − s · h 
p 
i i 
p 
j p 
i jx 
i j m ˆt but the 
left-hand-side is exactly m · l n − m · h 
on the other hand since t 
 tl 
 we have 
m · ˆt ≥ m · tl 
≥ np t l · l n − np t l · h 
combining and we get that np t l m np t − 
n 
h n 
l ≥ np t l − n 
h n 
l 
lemma algorithm satisfies cycle monotonicity 
proof taking p 
 pk 
and p 
 pk 
in we get that 
npk t l ≥ npk t l −nk k 
h nk k 
l summing this over all 
k k where k ≡ yields 
 computation of prices 
lemmas and show that our algorithm is a 
 approximation algorithm that satisfies cycle monotonicity 
thus by the discussion in section there exist prices that 
yield a truthful mechanism to obtain a polynomial-time 
mechanism we also need to show how to compute these 
prices or payments in polynomial-time it is not clear 
if the procedure outlined in section based on computing 
shortest paths in the allocation graph yields a polynomial 
time algorithm since the allocation graph has an 
exponential number of nodes one for each output assignment 
instead of analyzing the allocation graph we will leverage our 
proof of cycle monotonicity in particular inequality and 
simply spell out the payments 
recall that the utility of a player is ui pi − li where pi 
is the payment made to player i for convenience we will 
first specify negative payments i e the pis will actually 
be prices charged to the players and then show that these 
can be modified so that players have non-negative utilities 
 if they act truthfully let hi 
denote the number of jobs 
assigned to machine i in step by corollary we know 
that all these jobs are assigned to high machines according 
to the declared pis let h−i 
 
p 
i i hi 
and n−i 
p t 
p 
i i ni 
p t the payment pi to player i is defined as 
pi p −l · n−i 
p t p − h · h−i 
 p 
− h − l 
` 
np t p − np t l 
i p−i 
´ 
we can interpret our payments as equating the player s cost 
to a careful modification of the total load in the spirit of 
vcg prices the first and second terms in when 
subtracted from i s load li equate i s cost to the total load 
the term np t p − np t l 
i p−i is in fact equal to n−i 
p t p − 
n−i 
p t p t l 
i p−i since the low-load on i is at most tl 
i p−i 
 by claim thus the last term in equation implies 
that we treat the low jobs that were assigned beyond the 
tl 
i p−i threshold to machines other than i effectively as 
high jobs for the total utility calculation from i s point of 
view it is not clear how one could have conjured up these 
payments a priori in order to prove the truthfulness of our 
algorithm however by relying on cycle monotonicity we 
were not only able to argue the existence of payments but 
also our proof paved the way for actually inferring these 
payments the following lemma explicitly verifies that the 
payments defined above do indeed give a truthful mechanism 
lemma fix a player i and the other players 
declarations p−i let i s true type be p 
i then under the payments 
defined in i s utility when she declares her true type p 
i 
is at least her utility when she declares any other type p 
i 
proof let c 
i c 
i denote i s total cost defined as the 
negative of her utility when she declares p 
 and p 
 
respectively and the others declare p−i since p−i is fixed we 
omit p−i from the expressions below for notational clarity 
the true load of i when she declares her true type p 
i is 
l · ni 
p t p h · hi 
 p 
 and therefore 
c 
i l · np t p h · n − np t p 
 h − l 
` 
np t p − np t l 
i 
´ 
 n · h − h − l np t l 
i 
 
on the other hand i s true load when she declares p 
i is 
l · ni 
p t p − n 
h n 
l h · hi 
 n 
h − n 
l since 
i s true processing time vector is p 
i and thus 
c 
i n · h − h − l np t l 
i 
 h − l n 
h − h − l n 
l 
thus implies that c 
i ≤ c 
i 
price specifications are commonly required to satisfy in 
addition to truthfulness individual rationality i e a player s 
utility should be non-negative if she reveals her true value 
the payments given by are not individually rational as 
they actually charge a player a certain amount however 
it is well-known that this problem can be easily solved by 
adding a large-enough constant to the price definition in 
our case for example letting h denote the vector of all h s 
we can add the term n·h − h −l n h p−i t l 
i p−i to 
note that this is a constant for player i thus the new 
payments are pi p n · h − l · n−i 
p t p − h · h−i 
 p − 
 h −l 
` 
np t p −np t l 
i p−i n h p−i t l 
i p−i 
´ 
 as shown 
by this will indeed result in a non-negative utility for 
i since n h p−i t l 
i p−i ≤ n pi p−i t l 
i p−i for any type pi 
of player i this modification also ensures the additionally 
desired normalization property that if a player receives no 
jobs then she receives zero payment if player i receives the 
empty set for some type pi then she will also receive the 
empty set for the type h this is easy to verify for our 
specific algorithm and for the type h her utility equals zero 
thus by truthfulness this must also be the utility of every 
other declaration that results in i receiving the empty set 
this completes the proof of theorem 
 
 impossibility of exact implementation 
we now show that irrespective of computational 
considerations there does not exist a cycle-monotone algorithm for 
the l-h case with an approximation ratio better than 
let h α·l for some α that we will choose later 
there are two machines i ii and seven jobs consider the 
following two scenarios 
scenario every job has the same processing time on 
both machines jobs - are l and jobs are h any 
optimal schedule assigns jobs - to one machine and jobs 
 to the other and has makespan opt l the 
secondbest schedule has makespan at least second h l 
scenario if the algorithm chooses an optimal schedule 
for scenario assume without loss of generality that jobs 
 are assigned to machine ii in scenario machine i has 
the same processing-time vector machine ii lowers jobs 
 to l and increases - to h an optimal schedule has 
makespan l h where machine ii gets jobs and one 
of the jobs - the second-best schedule for this scenario 
has makespan at least second l 
theorem no deterministic truthful mechanism for the 
two-value scheduling problem can obtain an approximation 
ratio better than 
proof we first argue that a cycle-monotone algorithm 
cannot choose the optimal schedule in both scenarios this 
follows because otherwise cycle monotonicity is violated for 
machine ii taking p 
ii p 
ii to be machine ii s 
processingtime vectors for scenarios respectively we get 
p 
j p 
ii j − 
p 
ii j x 
ii j −x 
ii j l−h − thus any truthful 
mechanism must return a sub-optimal makespan in at least 
one scenario and therefore its approximation ratio is at least 
min 
˘second 
opt 
 second 
opt 
¯ 
≥ for α 
we remark that for the lj hj -case where there is a 
common ratio r 
hj 
lj 
for all jobs this generalizes the 
restricted-machines setting one can obtain a fractional 
truthful mechanism with efficiently computable prices that 
returns a schedule of makespan at most opt p for every 
p one can view each job j as consisting of lj sub-jobs of 
size on a machine i if pij lj and size r if pij hj 
for this new instance ˜p note that ˜pij ∈ r for every 
i j notice also that any assignment ˜x for the instance ˜p 
translates to a fractional assignment x for p where pijxij p 
j sub-job of j ˜pij ˜xij thus if we use algorithm to 
obtain a schedule for the instance ˜p equation translates 
precisely to for the assignment x moreover the prices 
for ˜p translate to prices for the instance p the number of 
sub-jobs assigned to low-machines in the flow-phase is 
simply the total work assigned to low-machines thus we can 
implement the above reduction by setting up a max-flow 
problem that seems to maximize the total work assigned 
to low machines moreover since we have a fractional 
domain we can use a more efficient greedy rule for packing the 
unassigned portions of jobs and argue that the fractional 
assignment has makespan at most opt p the assignment 
x need not however satisfy the condition that xij 
implies pij ≤ opt p for arbitrary r therefore the rounding 
procedure of lemma does not yield a -approximation 
truthful-in-expectation mechanism but if r opt p as 
in the restricted-machines setting this condition does hold 
so we get a -approximation truthful mechanism 
acknowledgments 
we thank elias koutsoupias for his help in refining the 
analysis of the lower bound in section and the reviewers for 
their helpful comments 
 references 
 n andelman y azar and m sorani truthful approximation 
mechanisms for scheduling selfish related machines in proc 
 nd stacs - 
 a archer mechanisms for discrete optimization with 
rational agents phd thesis cornell university 
 a archer and ´e tardos truthful mechanisms for 
one-parameter agents in proc nd focs pages - 
 
 v auletta r de-prisco p penna and g persiano 
deterministic truthful approximation mechanisms for 
scheduling related machines in proc st stacs pages 
 - 
 i bez´akov´a and v dani allocating indivisible goods in acm 
sigecom exchanges 
 s bikhchandani s chatterjee r lavi a mu alem 
n nisan and a sen weak monotonicity characterizes 
deterministic dominant-strategy implementation 
econometrica - 
 p briest p krysta and b vocking approximation 
techniques for utilitarian mechanism design in proc th 
stoc pages - 
 g christodoulou e koutsoupias and a vidali a lower 
bound for scheduling mechanisms in proc th soda pages 
 - 
 e clarke multipart pricing of public goods public choice 
 - 
 t groves incentives in teams econometrica - 
 
 h gui r muller and r v vohra characterizing dominant 
strategy mechanisms with multi-dimensional types 
working paper 
 l a hall approximation algorithms for scheduling in 
d hochbaum editor approximation algorithms for 
np-hard problems pws publishing ma 
 a kov´acs fast monotone -approximation algorithm for 
scheduling related machines in proc th esa pages 
 - 
 v s a kumar m v marathe s parthasarathy and 
a srinivasan approximation algorithms for scheduling on 
multiple machines in proc th focs pages - 
 r lavi a mu alem and n nisan towards a characterization 
of truthful combinatorial auctions in proc th focs pages 
 - 
 r lavi and c swamy truthful and near-optimal mechanism 
design via linear programming in proc th focs pages 
 - 
 d lehmann l o callaghan and y shoham truth 
revelation in approximately efficient combinatorial auctions 
journal of the acm - 
 j k lenstra d b shmoys and ´e tardos approximation 
algorithms for scheduling unrelated parallel machines math 
prog - 
 r j lipton e markakis e mossel and a saberi on 
approximately fair allocations of indivisible goods in proc 
 th ec pages - 
 a mu alem and m schapira setting lower bounds on 
truthfulness in proc th soda - 
 r myerson optimal auction design mathematics of 
operations research - 
 n nisan and a ronen algorithmic mechanism design 
games and econ behavior - 
 j c rochet a necessary and sufficient condition for 
rationalizability in a quasilinear context journal of 
mathematical economics - 
 m saks and l yu weak monotonicity suffices for truthfulness 
on convex domains in proc th ec pages - 
 d b shmoys and ´e tardos an approximation algorithm for 
the generalized assignment problem mathematical 
programming - 
 w vickrey counterspeculations auctions and competitive 
sealed tenders j finance - 
 
