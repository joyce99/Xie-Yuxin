approximately-strategyproof and tractable multi-unit 
auctions 
anshul kothari 
david c parkes† 
subhash suri 
abstract 
we present an approximately-efficient and 
approximatelystrategyproof auction mechanism for a single-good multi-unit 
allocation problem the bidding language in our auctions 
allows marginal-decreasing piecewise constant curves first we 
develop a fully polynomial-time approximation scheme for the 
multi-unit allocation problem which computes a 
 approximation in worst-case time t o n 
 given n bids 
each with a constant number of pieces second we embed this 
approximation scheme within a vickrey-clarke-groves vcg 
mechanism and compute payments to n agents for an 
asymptotic cost of o t log n the maximal possible gain from 
manipulation to a bidder in the combined scheme is bounded by 
 v where v is the total surplus in the efficient outcome 
categories and subject descriptors 
f theory of computation analysis of algorithms and 
problem complexity j computer applications social and 
behavioral sciences-economics 
general terms 
algorithms economics 
 introduction 
in this paper we present a fully polynomial-time 
approximation scheme for the single-good multi-unit auction problem our 
scheme is both approximately efficient and approximately 
strategyproof the auction settings considered in our paper are 
motivated by recent trends in electronic commerce for instance 
corporations are increasingly using auctions for their strategic 
sourcing we consider both a reverse auction variation and a 
forward auction variation and propose a compact and 
expressive bidding language that allows marginal-decreasing piecewise 
constant curves 
in the reverse auction we consider a single buyer with a 
demand for m units of a good and n suppliers each with a 
marginal-decreasing piecewise-constant cost function in 
addition each supplier can also express an upper bound or capacity 
constraint on the number of units she can supply the reverse 
variation models for example a procurement auction to obtain 
raw materials or other services e g circuit boards power 
suppliers toner cartridges with flexible-sized lots 
in the forward auction we consider a single seller with m 
units of a good and n buyers each with a marginal-decreasing 
piecewise-constant valuation function a buyer can also express 
a lower bound or minimum lot size on the number of units she 
demands the forward variation models for example an auction 
to sell excess inventory in flexible-sized lots 
we consider the computational complexity of implementing 
the vickrey-clarke-groves mechanism for the 
multiunit auction problem the vickrey-clarke-groves vcg 
mechanism has a number of interesting economic properties in this 
setting including strategyproofness such that truthful bidding is 
a dominant strategy for buyers in the forward auction and sellers 
in the reverse auction and allocative efficiency such that the 
outcome maximizes the total surplus in the system however as we 
discuss in section the application of the vcg-based approach 
is limited in the reverse direction to instances in which the total 
payments to the sellers are less than the value of the outcome 
to the buyer otherwise either the auction must run at a loss in 
these instances or the buyer cannot be expected to voluntarily 
choose to participate this is an example of the budget-deficit 
problem that often occurs in efficient mechanism design 
the computational problem is interesting because even with 
marginal-decreasing bid curves the underlying allocation 
problem turns out to weakly intractable for instance the classic 
 knapsack is a special case of this problem 
we model the 
 
however the problem can be solved easily by a greedy scheme 
if we remove all capacity constraints from the seller and all 
 
allocation problem as a novel and interesting generalization of 
the classic knapsack problem and develop a fully 
polynomialtime approximation scheme computing a -approximation 
in worst-case time t o n 
 ε where each bid has a fixed 
number of piecewise constant pieces 
given this scheme a straightforward computation of the vcg 
payments to all n agents requires time o nt we compute 
approximate vcg payments in worst-case time o αt log αn ε 
where α is a constant that quantifies a reasonable no-monopoly 
assumption specifically in the reverse auction suppose that 
c i is the minimal cost for procuring m units with all sellers i 
and c i \ i is the minimal cost without seller i then the 
constant α is defined as an upper bound for the ratio c i \i c i 
over all sellers i this upper-bound tends to as the number of 
sellers increases 
the approximate vcg mechanism is ε 
 ε 
 -strategyproof for 
an approximation to within of the optimal allocation 
this means that a bidder can gain at most ε 
 ε 
 v from a 
nontruthful bid where v is the total surplus from the efficient 
allocation as such this is an example of a computationally-tractable 
ε-dominance result 
in practice we can have good confidence 
that bidders without good information about the bidding 
strategies of other participants will have little to gain from attempts at 
manipulation 
section formally defines the forward and reverse auctions 
and defines the vcg mechanisms we also prove our claims 
about ε-strategyproofness section provides the generalized 
knapsack formulation for the multi-unit allocation problems and 
introduces the fully polynomial time approximation scheme 
section defines the approximation scheme for the payments in the 
vcg mechanism section concludes 
 related work 
there has been considerable interest in recent years in 
characterizing polynomial-time or approximable special cases of the 
general combinatorial allocation problem in which there are 
multiple different items the combinatorial allocation problem cap 
is both np-complete and inapproximable e g although 
some polynomial-time cases have been identified for the cap 
 introducing an expressive exclusive-or bidding language 
quickly breaks these special cases we identify a non-trivial but 
approximable allocation problem with an expressive 
exclusiveor bidding language-the bid taker in our setting is allowed to 
accept at most one point on the bid curve 
the idea of using approximations within mechanisms while 
retaining either full-strategyproofness or ε-dominance has received 
some previous attention for instance lehmann et al 
propose a greedy and strategyproof approximation to a single-minded 
combinatorial auction problem nisan ronen discussed 
approximate vcg-based mechanisms but either appealed to 
particular maximal-in-range approximations to retain full 
strategyproofness or to resource-bounded agents with information or 
computational limitations on the ability to compute strategies 
feigenminimum-lot size constraints from the buyers 
 
however this may not be an example of what feigenbaum 
shenker refer to as a tolerably-manipulable mechanism 
because we have not tried to bound the effect of such a 
manipulation on the efficiency of the outcome vcg mechanism do have a 
natural self-correcting property though because a useful 
manipulation to an agent is a reported value that improves the total 
value of the allocation based on the reports of other agents and 
the agent s own value 
baum shenker have defined the concept of strategically 
faithful approximations and proposed the study of 
approximations as an important direction for algorithmic mechanism 
design schummer and parkes et al have previously 
considered ε-dominance in the context of economic impossibility 
results for example in combinatorial exchanges 
eso et al have studied a similar procurement problem but 
for a different volume discount model this earlier work 
formulates the problem as a general mixed integer linear program and 
gives some empirical results on simulated data 
kalagnanam et al address double auctions where multiple 
buyers and sellers trade a divisible good the focus of this 
paper is also different it investigates the equilibrium prices using 
the demand and supply curves whereas our focus is on efficient 
mechanism design ausubel has proposed an ascending-price 
multi-unit auction for buyers with marginal-decreasing values 
 with an interpretation as a primal-dual algorithm 
 approximately-strategyproof 
vcg auctions 
in this section we first describe the marginal-decreasing 
piecewise bidding language that is used in our forward and reverse 
auctions continuing we introduce the vcg mechanism for the 
problem and the ε-dominance results for approximations to vcg 
outcomes we also discuss the economic properties of vcg 
mechanisms in these forward and reverse auction multi-unit 
settings 
 marginal-decreasing piecewise bids 
we provide a piecewise-constant and marginal-decreasing 
bidding language this bidding language is expressive for a 
natural class of valuation and cost functions fixed unit prices over 
intervals of quantities see figure for an example in 
addition we slightly relax the marginal-decreasing requirement to 
allow a bidder in the forward auction to state a minimal 
purchase amount such that she has zero value for quantities smaller 
than that amount a seller in the reverse auction to state a capacity 
constraint such that she has an effectively infinite cost to supply 
quantities in excess of a particular amount 
reverse auction bid 
 
 
 
 
quantity 
price 
 
 
 
 
quantity 
price 
forward auction bid 
figure marginal-decreasing piecewise constant bids in the 
forward auction bid the bidder offers per unit for quantity in 
the range per unit in the range and in the 
range her valuation is zero for quantities outside the range 
 in the reverse auction bid the cost of the seller is ∞ outside 
the range 
in detail in a forward auction a bid from buyer i can be 
written as a list of quantity-range unit-price tuples u 
i p 
i 
 u 
i p 
i umi− 
i pmi− 
i with an upper bound umi 
i on the 
quantity the interpretation is that the bidder s valuation in the 
 
 semi-open quantity range uj 
i uj 
i is pj 
i for each unit 
additionally it is assumed that the valuation is for quantities less 
than u 
i as well as for quantities more than um 
i this is 
implemented by adding two dummy bid tuples with zero prices in the 
range u 
i and umi 
i ∞ we interpret the bid list as 
defining a price function pbid i q qpj 
i if uj 
i ≤ q uj 
i where 
j mi − in order to resolve the boundary condition 
we assume that the bid price for the upper bound quantity umi 
i is 
pbid i umi 
i umi 
i pmi− 
i 
a seller s bid is similarly defined in the reverse auction the 
interpretation is that the bidder s cost in the semi-open 
quantity range uj 
i uj 
i is pj 
i for each unit additionally it is 
assumed that the cost is ∞ for quantities less than u 
i as well as 
for quantities more than um 
i equivalently the unit prices in the 
ranges u 
i and um 
i ∞ are infinity we interpret the bid list 
as defining a price function pask i q qpj 
i if uj 
i ≤ q uj 
i 
 vcg-based multi-unit auctions 
we construct the tractable and approximately-strategyproof 
multiunit auctions around a vcg mechanism we assume that all 
agents have quasilinear utility functions that is ui q p vi q − 
p for a buyer i with valuation vi q for q units at price p and 
ui q p p − ci q for a seller i with cost ci q at price p this 
is a standard assumption in the auction literature equivalent to 
assuming risk-neutral agents we will use the term payoff 
interchangeably for utility 
in the forward auction there is a seller with m units to sell 
we assume that this seller has no intrinsic value for the items 
given a set of bids from i agents let v i denote the maximal 
revenue to the seller given that at most one point on the bid curve 
can be selected from each agent and no more than m units of the 
item can be sold let x 
 x 
 x 
n denote the solution 
to this winner- determination problem where x 
i is the number 
of units sold to agent i similarly let v i \ i denote the 
maximal revenue to the seller without bids from agent i the vcg 
mechanism is defined as follows 
 receive piecewise-constant bid curves and capacity 
constraints from all the buyers 
 implement the outcome x 
that solves the winner-determination 
problem with all buyers 
 collect payment pvcg i pbid i x 
i − v i − v i \ i 
from each buyer and pass the payments to the seller 
in this forward auction the vcg mechanism is strategyproof 
for buyers which means that truthful bidding is a dominant 
strategy i e utility maximizing whatever the bids of other buyers 
in addition the vcg mechanism is allocatively-efficient and the 
payments from each buyer are always positive 
moreover each 
buyer pays less than its value and receives payoff v i −v i \ 
i in equilibrium this is precisely the marginal-value that buyer 
i contributes to the economic efficiency of the system 
in the reverse auction there is a buyer with m units to buy 
and n suppliers we assume that the buyer has value v 
to purchase all m units but zero value otherwise to simplify 
the mechanism design problem we assume that the buyer will 
truthfully announce this value to the mechanism 
the 
winner 
in fact the vcg mechanism maximizes the expected payoff 
to the seller across all efficient mechanisms even allowing for 
bayesian-nash implementations 
 
without this assumption the myerson-satterthwaite 
impossibility result would already imply that we should not expect 
an efficient trading mechanism in this setting 
determination problem in the reverse auction is to determine the 
allocation x 
 that minimizes the cost to the buyer or forfeits 
trade if the minimal cost is greater than value v 
let c i denote the minimal cost given bids from all sellers 
and let c i \i denote the minimal cost without bids from seller 
i we can assume without loss of generality that there is an 
efficient trade and v ≥ c i otherwise then the efficient 
outcome is no trade and the outcome of the vcg mechanism is no 
trade and no payments 
the vcg mechanism implements the outcome x 
that 
minimizes cost based on bids from all sellers and then provides 
payment pvcg i pask i x 
i v −c i −max v −c i\i to 
each seller the total payment is collected from the buyer again 
in equilibrium each seller s payoff is exactly the marginal-value 
that the seller contributes to the economic efficiency of the 
system in the simple case that v ≥ c i \ i for all sellers i this is 
precisely c i \ i − c i 
although the vcg mechanism remains strategyproof for 
sellers in the reverse direction its applicability is limited to cases in 
which the total payments to the sellers are less than the buyer s 
value otherwise there will be instances in which the buyer will 
not choose to voluntarily participate in the mechanism based on 
its own value and its beliefs about the costs of sellers this leads 
to a loss in efficiency when the buyer chooses not to participate 
because efficient trades are missed this problem with the size of 
the payments does not occur in simple single-item reverse 
auctions or even in multi-unit reverse auctions with a buyer that has 
a constant marginal-valuation for each additional item that she 
procures 
intuitively the problem occurs in the reverse multi-unit 
setting because the buyer demands a fixed number of items and 
has zero value without them this leads to the possibility of the 
trade being contingent on the presence of particular so-called 
pivotal sellers define a seller i as pivotal if c i ≤ v but 
c i\i v in words there would be no efficient trade without 
the seller any time there is a pivotal seller the vcg payments 
to that seller allow her to extract all of the surplus and the 
payments are too large to sustain with the buyer s value unless this 
is the only winning seller 
concretely we have this participation problem in the reverse 
auction when the total payoff to the sellers in equilibrium 
exceeds the total payoff from the efficient allocation 
v − c i ≥ 
i 
 v − c i − max v − c i \ i 
as stated above first notice that we require v c i \ i 
for all sellers i in other words there must be no pivotal sellers 
given this it is then necessary and sufficient that 
v − c i ≥ 
i 
 c i \ i − c i 
 
to make the reverse auction symmetric with the forward 
direction we would need a buyer with a constant marginal-value to 
buy the first m units and zero value for additional units the 
payments to the sellers would never exceed the buyer s value in 
this case conversely to make the forward auction symmetric 
with the reverse auction we would need a seller with a constant 
 and high marginal-cost to sell anything less than the first m 
units and then a low or zero marginal cost the total payments 
received by the seller can be less than the seller s cost for the 
outcome in this case 
 
in words the surplus of the efficient allocation must be greater 
than the total marginal-surplus provided by each seller 
consider an example with agents and v 
and c condition holds when c c 
 and c but not when c c 
and c in the first case the agent payoffs π 
 π π π π where is the seller is in the 
second case the payoffs are π − 
one thing we do know because the vcg mechanism will 
maximize the payoff to the buyer across all efficient mechanisms 
 is that whenever eq is not satisfied there can be no 
efficient auction mechanism 
 ε-strategyproofness 
we now consider the same vcg mechanism but with an 
approximation scheme for the underlying allocation problem we 
derive an ε-strategyproofness result that bounds the maximal 
gain in payoff that an agent can expect to achieve through a 
unilateral deviation from following a simple truth-revealing strategy 
we describe the result for the forward auction direction but it is 
quite a general observation 
as before let v i denote the value of the optimal solution 
to the allocation problem with truthful bids from all agents and 
v i \i denote the value of the optimal solution computed 
without bids from agent i let ˆv i and ˆv i \ i denote the value 
of the allocation computed with an approximation scheme and 
assume that the approximation satisfies 
 ˆv i ≥ v i 
for some we provide such an approximation scheme 
for our setting later in the paper let ˆx denote the allocation 
implemented by the approximation scheme 
the payoff to agent i for announcing valuation ˆvi is 
vi ˆxi 
j i 
ˆvj ˆxj − ˆv i \ i 
the final term is independent of the agent s announced value 
and can be ignored in an incentive-analysis however agent i 
can try to improve its payoff through the effect of its announced 
value on the allocation ˆx implemented by the mechanism in 
particular agent i wants the mechanism to select ˆx to maximize the 
sum of its true value vi ˆxi and the reported value of the other 
agents 
èj i ˆvj ˆxj if the mechanism s allocation algorithm is 
optimal then all the agent needs to do is truthfully state its value 
and the mechanism will do the rest however faced with an 
approximate allocation algorithm the agent can try to improve its 
payoff by announcing a value that corrects for the 
approximation and causes the approximation algorithm to implement the 
allocation that exactly maximizes the total reported value of the 
other agents together with its own actual value 
 
this condition is implied by the agents are substitutes 
requirement that has received some attention in the combinatorial 
auction literature because it characterizes the case in which vcg 
payments can be supported in a competitive equilibrium useful 
characterizations of conditions that satisfy agents are substitutes 
in terms of the underlying valuations of agents have proved quite 
elusive 
 
moreover although there is a small literature on 
maximallyefficient mechanisms subject to requirements of 
voluntaryparticipation and budget-balance i e with the mechanism 
neither introducing or removing money analytic results are only 
known for simple problems e g 
we can now analyze the best possible gain from 
manipulation to an agent in our setting we first assume that the other 
agents are truthful and then relax this in both cases the 
maximal benefit to agent i occurs when the initial approximation is 
worst-case with truthful reports from other agents this occurs 
when the value of choice ˆx is v i ε then an agent 
could hope to receive an improved payoff of 
v i − 
v i 
 ε 
 
ε 
 ε 
v i 
this is possible if the agent is able to select a reported type to 
correct the approximation algorithm and make the algorithm 
implement the allocation with value v i thus if other agents are 
truthful and with a ε -approximation scheme to the 
allocation problem then no agent can improve its payoff by more than 
a factor ε ε of the value of the optimal solution 
the analysis is very similar when the other agents are not 
truthful in this case an individual agent can improve its 
payoff by no more than a factor of the value of the optimal 
solution given the values reported by the other agents 
let v in the following theorem define the total value of the 
efficient allocation given the reported values of agents j i 
and the true value of agent i 
theorem a vcg-based mechanism with a 
ε allocation algorithm is 
−v strategyproof for agent i and 
agent i can gain at most this payoff through some non-truthful 
strategy 
notice that we did not need to bound the error on the allocation 
problems without each agent because the -strategyproofness 
result follows from the accuracy of the first-term in the vcg 
payment and is independent of the accuracy of the second-term 
however the accuracy of the solution to the problem without 
each agent is important to implement a good approximation to 
the revenue properties of the vcg mechanism 
 thegeneralized knapsack 
problem 
in this section we design a fully polynomial approximation 
scheme for the generalized knapsack which models the 
winnerdetermination problem for the vcg-based multi-unit auctions 
we describe our results for the reverse auction variation but the 
formulation is completely symmetric for the forward-auction 
in describing our approximation scheme we begin with a 
simple property the anchor property of an optimal knapsack 
solution we use this property to develop an o n 
 time -approximation 
for the generalized knapsack in turn we use this basic 
approximation to develop our fully polynomial-time approximation 
scheme fptas 
one of the major appeals of our piecewise bidding language 
is its compact representation of the bidder s valuation functions 
we strive to preserve this and present an approximation scheme 
that will depend only on the number of bidders and not the 
maximum quantity m which can be very large in realistic 
procurement settings 
the fptas implements an ε approximation to the 
optimal solution x 
 in worst-case time t o n 
 ε where n is 
the number of bidders and where we assume that the piecewise 
bid for each bidder has o pieces the dependence on the 
number of pieces is also polynomial if each bid has a maximum 
 
of c pieces then the running time can be derived by substituting 
nc for each occurrence of n 
 preliminaries 
before we begin let us recall the classic knapsack 
problem we are given a set of n items where the item i has value 
vi and size si and a knapsack of capacity m all sizes are 
integers the goal is to determine a subset of items of maximum 
value with total size at most m since we want to focus on a 
reverse auction the equivalent knapsack problem will be to choose 
a set of items with minimum value i e cost whose size exceeds 
m the generalized knapsack problem of interest to us can be 
defined as follows 
generalized knapsack 
instance a target m and a set of n lists where the ith list has 
the form 
bi u 
i p 
i umi− 
i pmi− 
i umi 
i i ∞ 
where uj 
i are increasing with j and pj 
i are decreasing with 
j and uj 
i pj 
i m are positive integers 
problem determine a set of integers xj 
i such that 
 one per list at most one xj 
i is non-zero for any i 
 membership xj 
i implies xj 
i ∈ uj 
i uj 
i 
 target 
èi 
èj xj 
i ≥ m and 
 objective 
èi 
èj pj 
i xj 
i is minimized 
this generalized knapsack formulation is a clear 
generalization of the classic knapsack in the latter each list consists of 
a single point si vi 
the connection between the generalized knapsack and our 
auction problem is transparent each list encodes a bid 
representing multiple mutually exclusive quantity intervals and one can 
choose any quantity in an interval but at most one interval can 
be selected choosing interval uj 
i uj 
i has cost pj 
i per unit 
the goal is to procure at least m units of the good at minimum 
possible cost the problem has some flavor of the continuous 
knapsack problem however there are two major differences that 
make our problem significantly more difficult intervals have 
boundaries and so to choose interval uj 
i uj 
i requires that at 
least uj 
i and at most uj 
i units must be taken unlike the 
classic knapsack we cannot sort the items bids by value size 
since different intervals in one list have different unit costs 
 a -approximation scheme 
we begin with a definition given an instance of the 
generalized knapsack we call each tuple tj 
i uj 
i pj 
i an anchor 
recall that these tuples represent the breakpoints in the piecewise 
constant curve bids we say that the size of an anchor tj 
i is uj 
i 
 
in fact because of the one per list constraint the generalized 
problem is closer in spirit to the multiple choice knapsack 
problem where the underling set of items is partitioned into 
disjoint subsets u u uk and one can choose at most one 
item from each subset ptas do exist for this problem 
and indeed one can convert our problem into a huge instance 
of the multiple choice knapsack problem by creating one group 
for each list put a quantity price point tuple x p for each 
possible quantity for a bidder into his group subset however 
this conversion explodes the problem size making it infeasible 
for all but the most trivial instances 
the minimum number of units available at this anchor s price pj 
i 
the cost of the anchor tj 
i is defined to be the minimum total price 
associated with this tuple namely cost tj 
i pj 
i uj 
i if j mi 
and cost tmi 
i pmi− 
i umi 
i 
in a feasible solution x x xn of the generalized 
knapsack we say that an element xi is an anchor if xi uj 
i for 
some anchor uj 
i otherwise we say that xi is midrange we 
observe that an optimal knapsack solution can always be 
constructed so that at most one solution element is midrange if there 
are two midrange elements x and x for bids from two different 
agents with x ≤ x then we can increment x and decrement 
x until one of them becomes an anchor see figure for an 
example 
lemma anchor property there exists an optimal 
solution of the generalized knapsack problem with at most one midrange 
element all other elements are anchors 
 midrange bid 
 
 
 
 
 
 
 
 
 
price quantity 
 
 
 
 
 
 
 
 
 
price 
quantity 
 i optimal solution with 
 midrange bids 
 ii optimal soltution with 
figure i an optimal solution with more than one bid not 
anchored ii an optimal solution with only one bid not 
anchored 
we use the anchor property to first obtain a polynomial-time 
 -approximation scheme we do this by solving several instances 
of a restricted generalized-knapsack problem which we call 
iknapsack where one element is forced to be midrange for a 
particular interval 
specifically suppose element x for agent l is forced to lie in 
its jth range uj 
 uj 
 while all other elements x xl− 
xl xn are required to be anchors or zero this corresponds 
to the restricted problem iknapsack j in which the goal is to 
obtain at least m − uj 
units with minimum cost element x 
is assumed to have already contributed uj 
units the value of 
a solution to iknapsack j represents the minimal additional 
cost to purchase the rest of the units 
we create n − groups of potential anchors where ith group 
contains all the anchors of the list i in the generalized knapsack 
the group for agent l contains a single element that represents 
the interval uj 
−uj 
 and the associated unit-price pj 
 this 
interval represents the excess number of units that can be taken 
from agent l in iknapsack j in addition to uj 
 which has 
already been committed in any other group we can choose at 
most one anchor 
the following pseudo-code describes our algorithm for this 
restriction of the generalized knapsack problem u is the union 
of all the tuples in n groups including a tuple t for agent l the 
size of this special tuple is defined as uj 
− uj 
 and the cost is 
defined as pj 
l uj 
−uj 
 r is the number of units that remain to 
be acquired s is the set of tuples accepted in the current tentative 
 
solution best is the best solution found so far variable skip is 
only used in the proof of correctness 
algorithm greedy j 
 sort all tuples of u in the ascending order of unit price in 
case of ties sort in ascending order of unit quantities 
 set mark i for all lists i n 
initialize r m − uj 
 s best skip ∅ 
 scan the tuples in u in the sorted order suppose the next 
tuple is tk 
i i e the kth anchor from agent i 
if mark i ignore this tuple 
otherwise do the following steps 
 if size tk 
i r and i 
return min cost s rpj 
 cost best 
 if size tk 
i r and cost tk 
i ≤ cost s 
return min cost s cost tk 
i cost best 
 if size tk 
i r and cost tk 
i cost s 
add tk 
i to skip set best to s ∪ tk 
i if cost 
improves 
 if size tk 
i ≤ r then 
add tk 
i to s mark i subtract size tk 
i 
from r 
the approximation algorithm is very similar to the 
approximation algorithm for knapsack since we wish to minimize the total 
cost we consider the tuples in order of increasing per unit cost if 
the size of tuple tk 
i is smaller than r then we add it to s update 
r and delete from u all the tuples that belong to the same group 
as tk 
i if size tk 
i is greater than r then s along with tk 
i forms a 
feasible solution however this solution can be far from optimal 
if the size of tk 
i is much larger than r if total cost of s and tk 
i 
is smaller than the current best solution we update best one 
exception to this rule is the tuple t since this tuple can be taken 
fractionally we update best if the sum of s s cost and fractional 
cost of t is an improvement 
the algorithm terminates in either of the first two cases or 
when all tuples are scanned in particular it terminates whenever 
we find a tk 
i such that size tk 
i is greater than r but cost tk 
i is 
less than cost s or when we reach the tuple representing agent 
l and it gives a feasible solution 
lemma suppose a 
is an optimal solution of the 
generalized knapsack and suppose that element l j is midrange in the 
optimal solution then the cost v l j returned by greedy j 
satisfies 
v j cost tj 
 ≤ cost a 
 
proof let v j be the value returned by greedy j and 
let v 
 j be an optimal solution for iknapsack j consider 
the set skip at the termination of greedy j there are two 
cases to consider either some tuple t ∈ skip is also in v 
 j 
or no tuple in skip is in v 
 j in the first case let st be the 
tentative solution s at the time t was added to skip because 
t ∈ skip then size t r and st together with t forms a 
feasible solution and we have 
v j ≤ cost best ≤ cost st cost t 
again because t ∈ skip then cost t cost st and we have 
v j cost t on the other hand since t is included in 
v 
 j we have v 
 j ≥ cost t these two inequalities 
imply the desired bound 
v 
 j ≤ v j v 
 j 
in the second case imagine a modified instance of 
iknapsack j which excludes all the tuples of the set skip since 
none of these tuples were included in v 
 j the optimal 
solution for the modified problem should be the same as the one for 
the original suppose our approximation algorithm returns the 
value v j for this modified instance let t be the last tuple 
considered by the approximation algorithm before termination 
on the modified instance and let st be the corresponding 
tentative solution set in that step since we consider tuples in order 
of increasing per unit price and none of the tuples are going to 
be placed in the set skip we must have cost st v 
 j 
because st is the optimal way to obtain size st 
we also have cost t ≤ cost st and the following 
inequalities 
v j ≤ v j ≤ cost st cost t 
 v 
 j 
the inequality v j ≤ v j follows from the fact that a 
tuple in the skip list can only affect the best but not the tentative 
solutions therefore dropping the tuples in the set skip can only 
make the solution worse 
the above argument has shown that the value returned by greedy j 
is within a factor of the optimal solution for iknapsack j 
we now show that the value v j plus cost tj 
 is a -approximation 
of the original generalized knapsack problem 
let a 
be an optimal solution of the generalized knapsack 
and suppose that element xj 
is midrange let x− to be set of 
the remaining elements either zero or anchors in this solution 
furthermore define x xj 
− uj 
 thus 
cost a 
 cost xl cost tj 
l cost x−l 
it is easy to see that x− x is an optimal solution for iknapsack j 
since v j is a -approximation for this optimal solution we 
have the following inequalities 
v j cost tj 
 ≤ cost tj 
 cost x cost x− 
≤ cost x cost tj 
 cost x− 
≤ cost a 
 
this completes the proof of lemma 
it is easy to see that after an initial sorting of the tuples in u 
the algorithm greedy j takes o n time we have our first 
polynomial approximation algorithm 
theorem a -approximation of the generalized knapsack 
problem can be found in time o n 
 where n is number of item 
lists each of constant length 
proof we run the algorithm greedy j once for each 
tuple l j as a candidate for midrange there are o n tuples 
and it suffices to sort them once the total cost of the algorithm is 
o n 
 by lemma there is an optimal solution with at most 
one midrange element so our algorithm will find a -approximation 
as claimed 
the dependence on the number of pieces is also polynomial 
if each bid has a maximum of c pieces then the running time is 
o nc 
 
 
 an approximation scheme 
we now use the -approximation algorithm presented in the 
preceding section to develop a fully polynomial approximation 
 fptas for the generalized knapsack problem the high level 
idea is fairly standard but the details require technical care we 
use a dynamic programming algorithm to solve iknapsack j 
for each possible midrange element with the -approximation 
algorithm providing an upper bound on the value of the solution 
and enabling the use of scaling on the cost dimension of the 
dynamic programming dp table 
consider for example the case that the midrange element is 
x which falls in the range uj 
 uj 
 in our fptas rather 
than using a greedy approximation algorithm to solve 
iknapsack j we construct a dynamic programming table to 
compute the minimum cost at which at least m − uj 
units can 
be obtained using the remaining n − lists in the generalized 
knapsack 
suppose g i r denotes the maximum number of units that 
can be obtained at cost at most r using only the first i lists in the 
generalized knapsack then the following recurrence relation 
describes how to construct the dynamic programming table 
g r 
g i r max 
´ g i − r 
max 
j∈β i r 
 g i − r − cost tj 
i uj 
i 
µ 
where β i r j ≤ j ≤ mi cost tj 
i ≤ r is the set 
of anchors for agent i as convention agent i will index the row 
and cost r will index the column 
this dynamic programming algorithm is only pseudo-polynomial 
since the number of column in the dynamic programming table 
depends upon the total cost however we can convert it into a 
fptas by scaling the cost dimension 
let a denote the -approximation to the generalized knapsack 
problem with total cost cost a let ε denote the desired 
approximation factor we compute the scaled cost of a tuple tj 
i 
denoted scost tj 
i as 
scost tj 
i 
n cost tj 
i 
εcost a 
 
this scaling improves the running time of the algorithm 
because the number of columns in the modified table is at most 
n 
ε 
 and independent of the total cost however the computed 
solution might not be an optimal solution for the original 
problem we show that the error introduced is within a factor of ε of 
the optimal solution 
as a prelude to our approximation guarantee we first show 
that if two different solutions to the iknapsack problem have 
equal scaled cost then their original unscaled costs cannot 
differ by more than εcost a 
lemma let x and y be two distinct feasible solutions of 
iknapsack j excluding their midrange elements if x and y 
have equal scaled costs then their unscaled costs cannot differ 
by more than εcost a 
proof let ix and iy respectively denote the indicator 
functions associated with the anchor vectors x and y-there is in 
position ix i k if the xk 
i since x and y has equal scaled 
cost 
i k 
scost tk 
i ix i k 
i k 
scost tk 
i iy i k 
however by the scaled costs satisfy the following 
inequalities 
 scost tk 
i − εcost a 
n 
≤ cost tk 
i ≤ 
scost tk 
i εcost a 
n 
 
substituting the upper-bound on scaled cost from for cost x 
the lower-bound on scaled cost from for cost y and using 
equality to simplify we have 
cost x − cost y ≤ 
εcost a 
n 
i k 
iy i k ≤ εcost a 
the last inequality uses the fact that at most n components 
of an indicator vector are non-zero that is any feasible solution 
contains at most n tuples 
finally given the dynamic programming table for iknapsack j 
we consider all the entries in the last row of this table g n− r 
these entries correspond to optimal solutions with all agents 
except l for different levels of cost in particular we consider the 
entries that provide at least m − uj 
units together with a 
contribution from agent l we choose the entry in this set that 
minimizes the total cost defined as follows 
cost g n − r max uj 
 m − g n − r pj 
 
where cost is the original unscaled cost associated with 
entry g n− r it is worth noting that unlike the -approximation 
scheme for iknapsack j the value computed with this fptas 
includes the cost to acquire uj 
l units from l 
the following lemma shows that we achieve a ε -approximation 
lemma suppose a 
is an optimal solution of the 
generalized knapsack problem and suppose that element l j is 
midrange in the optimal solution then the solution a l j from 
running the scaled dynamic-programming algorithm on iknapsack j 
satisfies 
cost a l j ≤ ε cost a 
 
proof let x− denote the vector of the elements in 
solution a 
without element l then by definition cost a 
 
cost x− pj 
xj 
 let r scost x− be the scaled cost 
associated with the vector x− now consider the dynamic 
programming table constructed for iknapsack j and consider its 
entry g n − r let a denote the -approximation to the 
generalized knapsack problem and a l j denote the solution from 
the dynamic-programming algorithm 
suppose y− is the solution associated with this entry in our 
dynamic program the components of the vector y− are the 
quantities from different lists since both x− and y− have equal 
scaled costs by lemma their unscaled costs are within εcost a 
of each other that is 
cost y− − cost x− ≤ εcost a 
now define yj 
 max uj 
 m − 
èi 
èj yj 
i this is the 
contribution needed from to make y− yj 
 a feasible solution 
among all the equal cost solutions our dynamic programming 
tables chooses the one with maximum units therefore 
i j 
yj 
i ≥ 
i j 
xj 
i 
 
therefore it must be the case that yj 
≤ xj 
 because yj 
 y− 
is also a feasible solution if our algorithm returns a solution with 
cost cost a l j then we must have 
cost a l j ≤ cost y− pj 
yj 
≤ cost x− εcost a pj 
xj 
≤ ε cost a 
 
where we use the fact that cost a ≤ cost a 
 
putting this together our approximation scheme for the 
generalized knapsack problem will iterate the scheme described above 
for each choice of the midrange element l j and choose the 
best solution from among these o n solutions 
for a given midrange the most expensive step in the algorithm 
is the construction of dynamic programming table which can be 
done in o n 
 ε time assuming constant intervals per list thus 
we have the following result 
theorem we can compute an ε approximation to 
the solution of a generalized knapsack problem in worst-case 
time o n 
 ε 
the dependence on the number of pieces is also polynomial if 
each bid has a maximum of c pieces then the running time can 
be derived by substituting cn for each occurrence of n 
 computing vcg payments 
we now consider the related problem of computing the vcg 
payments for all the agents a naive approach requires solving 
the allocation problem n times removing each agent in turn in 
this section we show that our approximation scheme for the 
generalized knapsack can be extended to determine all n payments 
in total time o αt log αn ε where ≤ c i\i c i ≤ α 
for a constant upper bound α and t is the complexity of 
solving the allocation problem once this α-bound can be justified 
as a no monopoly condition because it bounds the marginal 
value that a single buyer brings to the auction similarly in the 
reverse variation we can compute the vcg payments to each 
seller in time o αt log αn ε where α bounds the ratio c i\ 
i c i for all i 
our overall strategy will be to build two dynamic 
programming tables forward and backward for each midrange element 
 l j once the forward table is built by considering the agents 
in the order of their indices where as the backward table is built 
by considering them in the reverse order the optimal solution 
corresponding to c i \ i can be broken into two parts one 
corresponding to first i − agents and the other corresponding to 
last n − i agents as the i − th row of the forward table 
corresponds to the sellers with first i− indices an approximation 
to the first part will be contained in i − th row of the forward 
table similarly n− i th row of the backward table will contain 
an approximation for the second part we first present a 
simple but an inefficient way of computing the approximate value of 
c i \ i which illustrates the main idea of our algorithm then 
we present an improved scheme which uses the fact that the 
elements in the rows are sorted to compute the approximate value 
more efficiently 
in the following we concentrate on computing an allocation 
with xj 
being midrange and some agent i l removed this 
will be a component in computing an approximation to c i \ i 
the value of the solution to the generalized knapsack without bids 
from agent i we begin with the simple scheme 
 a simple approximation scheme 
we implement the scaled dynamic programming algorithm for 
iknapsack j with two alternate orderings over the other 
sellers k l one with sellers ordered n and one with 
sellers ordered n n − we call the first table the 
forward table and denote it f and the second table the backward 
table and denote it bl the subscript reminds us that the agent 
is midrange 
in building these tables we use the same scaling factor as 
before namely the cost of a tuple tj 
i is scaled as follows 
scost tj 
i 
ncost tj 
i 
εcost a 
where cost a is the upper bound on c i given by our 
 approximation scheme in this case because c i \ i can be α 
times c i the scaled value of c i \ i can be at most nα ε 
therefore the cost dimension of our dynamic program s table 
will be nα ε 
fltable 
f i− l 
 
 
 
i− 
 m− m 
n− 
g 
 m− m 
b n−i 
n− 
n− 
n−i 
 
lh 
table bl 
figure computing vcg payments m nα 
ε 
now suppose we want to compute a -approximation 
to the generalized knapsack problem restricted to element l j 
midrange and further restricted to remove bids from some seller 
i l call this problem iknapsack−i 
 j 
recall that the ith row of our dp table stores the best solution 
possible using only the first i agents excluding agent l all of 
them either cleared at zero or on anchors these first i agents 
are a different subset of agents in the forward and the backward 
tables by carefully combining one row of fl with one row of 
bl we can compute an approximation to iknapsack−i 
 j we 
consider the row of fl that corresponds to solutions constructed 
from agents i − skipping agent l we consider the 
row of bl that corresponds to solutions constructed from agents 
 i i n again skipping agent l the rows are labeled 
fl i − and bl n − i respectively 
the scaled costs for 
acquiring these units are the column indices for these entries to 
solve iknapsack−i 
 j we choose one entry from row f i− 
and one from row b n−i such that their total quantity exceeds 
m − uj 
and their combined cost is minimum over all such 
combinations formally let g ∈ fl i − and h ∈ bl n − 
denote entries in each row with size g size h denoting the 
number of units and cost g and cost h denoting the unscaled 
cost associated with the entry we compute the following subject 
 
we could label the tables with both and j to indicate the jth 
tuple is forced to be midrange but omit j to avoid clutter 
 
to be precise the index of the rows are i − and n − i for 
fl and bl when l i and i − and n − i − respectively 
when l i 
 
to the condition that g and h satisfy size g size h m − 
uj 
 
min 
g∈f i− h∈b n−i 
òcost g cost h 
pj 
· max uj 
 m − size g − size h 
ó 
lemma suppose a−i 
is an optimal solution of the 
generalized knapsack problem without bids from agent i and suppose 
that element l j is the midrange element in the optimal 
solution then the expression in eq for the restricted problem 
iknapsack−i 
 j computes a ε -approximation to a−i 
 
proof from earlier we define cost a−i 
 c i \ i we 
can split the optimal solution a−i 
 into three disjoint parts xl 
corresponds to the midrange seller xi corresponds to first i − 
sellers skipping agent l if l i and x−i corresponds to last 
n − i sellers skipping agent l if l i we have 
cost a−i 
 cost xi cost x−i pj 
xj 
let ri scost xi and r−i scost x−i let yi and y−i 
be the solution vectors corresponding to scaled cost ri and r−i 
in f i − and b n − i respectively from lemma we 
conclude that 
cost yi cost y−i − cost xi − cost x−i ≤ εcost a 
where cost a is the upper-bound on c i computed with the 
 -approximation 
among all equal scaled cost solutions our dynamic program 
chooses the one with maximum units therefore we also have 
 size yi ≥ size xi and size y−i ≥ size x−i 
where we use shorthand size x to denote total number of units 
in all tuples in x 
now define yj 
l max uj 
l m −size yi −size y−i from 
the preceding inequalities we have yj 
l ≤ xj 
l since yj 
l yi y−i 
is also a feasible solution to the generalized knapsack problem 
without agent i the value returned by eq is at most 
cost yi cost y−i pj 
l yj 
l ≤ c i \ i εcost a 
≤ c i \ i cost a 
 ε 
≤ c i \ i c i \ i ε 
this completes the proof 
a naive implementation of this scheme will be inefficient 
because it might check nα ε 
pairs of elements for any 
particular choice of l j and choice of dropped agent i in the next 
section we present an efficient way to compute eq and 
eventually to compute the vcg payments 
 improved approximation scheme 
our improved approximation scheme for the winner-determination 
problem without agent i uses the fact that elements in f i − 
and b n − i are sorted specifically both unscaled cost and 
quantity i e size increases from left to right as before let 
g and h denote generic entries in f i − and b n − i 
respectively to compute eq we consider all the tuple pairs and 
first divide the tuples that satisfy condition size g size h 
m − uj 
l into two disjoint sets for each set we compute the 
best solution and then take the best between the two sets 
 case i size g size h ≥ m − uj 
l 
the problem reduces to 
min 
g∈f i− h∈b n−i 
òcost g cost h pj 
l uj 
ó 
we define a pair g h to be feasible if size g size h ≥ 
m − uj 
l now to compute eq we do a forward and backward 
walk on f i − and b n − i respectively we start from 
the smallest index of f i − and move right and from the 
highest index of b n − i and move left let g h be the 
current pair if g h is feasible we decrement b s pointer that 
is move backward otherwise we increment f s pointer the 
feasible pairs found during the walk are used to compute eq 
the complexity of this step is linear in size of f i − which 
is o nα ε 
 case ii m − uj 
l ≤ size g size h ≤ m − uj 
l 
the problem reduces to 
min 
g∈f i− h∈b n−i 
òcost g cost h 
pj 
l m − size g − size h 
ó 
to compute the above equation we transform the above 
problem to another problem using modified cost which is defined as 
mcost g cost g − pj 
l · size g 
mcost h cost h − pj 
l · size h 
the new problem is to compute 
min 
g∈f i− h∈b n−i 
òmcost g mcost h pj 
l m 
ó 
the modified cost simplifies the problem but unfortunately 
the elements in f i − and b n − i are no longer sorted 
with respect to mcost however the elements are still sorted in 
quantity and we use this property to compute eq call a pair 
 g h feasible if m − uj 
l ≤ size g size h ≤ m − uj 
l 
define the feasible set of g as the elements h ∈ b n − i that 
are feasible given g as the elements are sorted by quantity the 
feasible set of g is a contiguous subset of b n − i and shifts 
left as g increases 
 
 
begin end 
b n−i 
 
 
f i− l 
l 
figure the feasible set of g defined on b n − i is 
 when m − uj 
l and m − uj 
l begin and 
end represent the start and end pointers to the feasible set 
therefore we can compute eq by doing a forward and 
backward walk on f i − and b n − i respectively we walk on 
b n − i starting from the highest index using two pointers 
begin and end to indicate the start and end of the current 
feasible set we maintain the feasible set as a min heap where the 
key is modified cost to update the feasible set when we 
increment f s pointer move forward we walk left on b first using 
end to remove elements from feasible set which are no longer 
 
feasible and then using begin to add new feasible elements for 
a given g the only element which we need to consider in g s 
feasible set is the one with minimum modified cost which can 
be computed in constant time with the min heap so the main 
complexity of the computation lies in heap updates since any 
element is added or deleted at most once there are o nα 
ε 
 heap 
updates and the time complexity of this step is o nα 
ε 
log nα 
ε 
 
 collecting the pieces 
the algorithm works as follows first using the 
approximation algorithm we compute an upper bound on c i we use 
this bound to scale down the tuple costs using the scaled costs 
we build the forward and backward tables corresponding to each 
tuple l j the forward tables are used to compute c i to 
compute c i \ i we iterate over all the possible midrange 
tuples and use the corresponding forward and backward tables to 
compute the locally optimal solution using the above scheme 
among all the locally optimal solutions we choose one with the 
minimum total cost 
the most expensive step in the algorithm is computation of 
c i \ i the time complexity of this step is o n 
α 
ε 
log nα 
ε 
 
as we have to iterate over all o n choices of tj 
l for all l 
i and each time use the above scheme to compute eq in 
the worst case we might need to compute c i \ i for all n 
sellers in which case the final complexity of the algorithm will 
be o n 
α 
ε 
log nα 
ε 
 
theorem we can compute an -strategyproof 
approximation to the vcg mechanism in the forward and reverse 
multi-unit auctions in worst-case time o n 
α 
ε 
log nα 
ε 
 
it is interesting to recall that t o n 
ε 
 is the time 
complexity of the fptas to the generalized knapsack problem with all 
agents our combined scheme computes an approximation to the 
complete vcg mechanism including payments to o n agents 
in time complexity o t log n ε taking the no-monopoly 
parameter α as a constant thus our algorithm performs much 
better than the naive scheme which computes the vcg 
payment for each agent by solving a new instance of generalized 
knapsack problem the speed up comes from the way we solve 
iknapsack−i 
 j time complexity of computing iknapsack−i 
 j 
by creating a new dynamic programming table will be o n 
ε 
 
but by using the forward and backward tables the complexity is 
reduced to o n 
ε 
log n 
ε 
 we can further improve the time 
complexity of our algorithm by computing eq more efficiently 
currently the algorithm uses heap which has logarithmic 
update time in worst case we can have two heap update operations 
for each element which makes the time complexity super linear 
if we can compute eq in linear time then the complexity of 
computing the vcg payment will be same as the complexity of 
solving a single generalized knapsack problem 
 conclusions 
we presented a fully polynomial-time approximation scheme 
for the single-good multi-unit auction problem using marginal 
decreasing piecewise constant bidding language our scheme 
is both approximately efficient and approximately strategyproof 
within any specified factor ε as such it is an example of 
computationally tractable ε-dominance result as well as an 
example of a non-trivial but approximable allocation problem it 
is particularly interesting that we are able to compute the 
payments to n agents in a vcg-based mechanism in worst-case time 
o t log n where t is the time complexity to compute the 
solution to a single allocation problem 
 references 
 l m ausubel and p r milgrom ascending auctions with package 
bidding frontiers of theoretical economics - 
 s bikchandani s de vries j schummer and r v vohra linear 
programming and vickrey auctions technical report anderson 
graduate school of management u c l a 
 s bikchandani and j m ostroy the package assignment model 
journal of economic theory forthcoming 
 k chatterjee and w samuelson bargaining under incomplete 
information operations research - 
 e h clarke multipart pricing of public goods public choice 
 - 
 s de vries and r v vohra combinatorial auctions a survey 
informs journal on computing forthcoming 
 m eso s ghosh j r kalagnanam and l ladanyi bid evaluation 
in procurement auctions with piece-wise linear supply curves 
technical report ibm tj watson research center in 
preparation 
 j feigenbaum and s shenker distributed algorithmic mechanism 
design recent results and future directions in proceedings of 
the th international workshop on discrete algorithms and 
methods for mobile computing and communications pages - 
 
 m r garey and d s johnson computers and intractability a 
guide to the theory of np-completeness w h freeman and 
company new york 
 g v gens and e v levner computational complexity of 
approximation algorithms for combinatorial problems in 
mathematical foundation of computer science - 
 t groves incentives in teams econometrica - 
 j r kalagnanam a j davenport and h s lee computational 
aspects of clearing continuous call double auctions with 
assignment constraints and indivisible demand electronic 
commerce journal - 
 v krishna auction theory academic press 
 v krishna and m perry efficient mechanism design technical 
report pennsylvania state university available at 
http econ la psu edu ˜vkrishna vcg ps 
 d lehmann l i o callaghan and y shoham truth revelation in 
approximately efficient combinatorial auctions jacm 
 - september 
 r b myerson optimal auction design mathematics of operation 
research - 
 r b myerson and m a satterthwaite efficient mechanisms for 
bilateral trading journal of economic theory - 
 n nisan and a ronen computationally feasible vcg 
mechanisms in acm-ec pages - 
 d c parkes j r kalagnanam and m eso achieving 
budget-balance with vickrey-based payment schemes in 
exchanges in ijcai 
 m h rothkopf a pekeˇc and r m harstad computationally 
manageable combinatorial auctions management science 
 - 
 j schummer almost dominant strategy implementation technical 
report meds department kellogg graduate school of 
management 
 w vickrey counterspeculation auctions and competitive sealed 
tenders journal of finance - 
 
