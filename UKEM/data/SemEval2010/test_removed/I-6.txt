dynamic semantics for agent communication languages 
michael rovatsos 
school of informatics 
the university of edinburgh 
edinburgh eh le 
united kingdom 
mrovatso inf ed ac uk 
abstract 
this paper proposes dynamic semantics for agent 
communication languages acls as a method for tackling some 
of the fundamental problems associated with agent 
communication in open multiagent systems based on the idea 
of providing alternative semantic variants for speech acts 
and transition rules between them that are contingent on 
previous agent behaviour our framework provides an 
improved notion of grounding semantics in ongoing interaction 
a simple mechanism for distinguishing between compliant 
and expected behaviour and a way to specify sanction and 
reward mechanisms as part of the acl itself we extend a 
common framework for commitment-based acl semantics 
to obtain these properties discuss desiderata for the design 
of concrete dynamic semantics together with examples and 
analyse their properties 
categories and subject descriptors 
i artificial intelligence distributed artificial 
intelligence-multiagent systems 
 introduction 
the field of agent communication language acl 
research has long been plagued by problems of verifiability 
and grounding early mentalistic semantics 
that specify the semantics of speech acts in terms of 
preand post-conditions contingent on mental states of the 
participants e g lack verifiability regarding 
compliance of agents with the intended semantics as the 
mental states of agents cannot be observed in open multiagent 
systems mass unable to safeguard themselves against 
abuse by malicious deceptive or malfunctioning agents 
mentalistic semantics are inherently unreliable and 
inappropriate for use in open mas in which agents with potentially 
conflicting objectives might deliberately exploit their 
adversaries conceptions of message semantics to provoke a certain 
behaviour 
commitment-based semantics on the other 
hand define the meaning of messages exchanged among 
agents in terms of publicly observable commitments 
i e pledges to bring about a state of affairs or to perform 
certain actions such semantics solve the verifiability problem 
as they allow for tracing the status of existing commitments 
at any point in time given observed messages and actions 
so that any observer can for example establish whether an 
agent has performed a promised action however this can 
only be done a posteriori and this creates a grounding 
problem as no expectations regarding what will happen in the 
future can be formed at the time of uttering or receiving a 
message purely on the grounds of the acl semantics 
further this implies that the semantics specification does 
not provide an interface to agents deliberation and 
planning mechanisms and hence it is unclear how rational agents 
would be able to decide whether to subscribe to a suggested 
acl semantics when it is deployed 
finally none of the existing approaches allows the acl 
to specify how to respond to a violation of its semantics by 
individual agents this has two implications firstly it is 
left it up to the individual agent to reason about potential 
violations i e to bear the burden of planning its own 
reaction to others non-compliant behaviour e g in order to 
sanction them and to anticipate others reactions to own 
misconduct without any guidance from the acl 
specification secondly existing approaches fail to exploit the 
possibilities of sanctioning and rewarding certain behaviours in a 
communication-inherent way by modifying the future 
meaning of messages uttered or received by compliant deviant 
agents 
in this paper we propose dynamic semantics dss for 
acls as a solution to these problems our notion of ds 
is based on the very simple idea of defining different 
alternatives for the meaning of individual speech acts so-called 
semantic variants in an acl semantics specification and 
transition rules between semantic states i e collections of 
variants for different speech acts that describe the current 
meaning of the acl these elements taken together result in 
a fsm-like view of acl specifications where each individual 
state provides a complete acl semantics and state 
transitions are triggered by observed agent behaviour in order to 
 reflect future expectations based on previous interaction 
experience and sanction or reward certain kinds of 
behaviour 
in defining a ds framework for commitment-based acls 
this paper makes three contributions 
 an extension of commitment-based acl semantics to 
provide an improved notion of grounding commitments 
in agent interaction and to allow acl specifications to 
be directly used for planning-based rational decision 
making 
 a simple way of distinguishing between compliant and 
expected behaviour with respect to an acl 
specification that enables reasoning about the potential 
behaviour of agents purely from an acl semantics 
perspective 
 a mechanism for specifying how meaning evolves 
with agent behaviour and how this can be used to 
describe communication-inherent sanctioning and 
rewarding mechanisms essential to the design of open 
mass 
furthermore we discuss desiderata for ds design that can 
be derived from our framework present examples and 
analyse their properties 
the remainder of this paper is structured as follows 
section introduces a formal framework for dynamic acl 
semantics in section we present an analysis and discussion 
of this framework and discuss desiderata for the design of 
acls with dynamic semantics section reviews related 
approaches and section concludes 
 formal framework 
our general framework for describing the kind of mass 
we are interested in is fairly simple let ag n 
a finite set of agents aci i∈ag a collection of action sets 
 where aci are the actions of agent i a ×n 
i aci the 
joint action space and env a set of environment states a 
run is a sequence r e 
a 
→ 
at− 
→ et where ai ∈ a ai j 
denotes the action of agent j in this tuple and ei ∈ env 
we define r t last r et r j is short for the j-long 
initial sub-sequence of r and we write r r for any run r 
iff ∃j ∈ n r r j 
writing r env a for the set of all possible runs we can 
view each agent i as a function gi r env a → aci 
describing the agent s action choices depending on the 
history of previous environment states and joint actions the 
set of all agent functions for i given a and env is 
denoted by gi env a the finite discrete stationary 
fully accessible deterministic environment is defined by a 
state transformer function f env × a → env so that 
the system s operation for an initial state e is defined by 
ei f ei g e 
a 
→ 
ai− 
→ ei for all i ≥ g is the joint 
vector of functions gi this definition implies that 
execution of actions is synchronised among agents so that the 
system evolves though an execution of rounds where all 
agents perform their actions simultaneously 
we denote the set of all runs given a particular 
configuration of agent functions g by r env a g we write 
gi ∼ r where gi an agent function and r a run iff ∀ ≤ 
j ≤ r gi r j aj i i e gi is compatible with r in 
every time step as far as i s actions are concerned 
we use a standard propositional logical language l with 
entailment relation e ϕ for e ∈ env and ϕ ∈ l 
deunset pending 
cancelled 
active 
violated 
fulfilled 
figure commitment states and state transitions 
in the fornara and colombetti model edges drawn 
using solid lines indicate transitions brought about 
by agent communication dashed lines indicate 
physical agent action or environmental events that cause 
state transitions 
fined in the usual way 
we introduce special propositions 
done i a for each action a ∈ ∪n 
i aci in l to denote it is 
true that action a has just been performed extending 
to runs r in the following way 
r ϕ if last r ϕ 
r done i a if r e 
a 
→ 
at− 
→ et ∧ a at− i 
i e done i a is exactly true for those actions that made up 
part of the joint action vector ai− in the predecessor state 
and all other formulae that were entailed by the last state of 
r are still valid our model implies that each agent executes 
exactly one action in each time step 
 commitments 
our notion of commitments is based on a slight variation 
of the framework proposed by fornara and colombetti 
commitments come into existence as unset e g when a 
request for achieving χ if a certain condition ϕ becomes true 
is issued from i to j the commitment becomes pending if 
the debtor j is required to fulfill it e g after having accepted 
it a pending commitment will become active if its 
condition ϕ becomes true and if χ is brought about in that case 
it becomes fulfilled otherwise violated commitments 
can become cancelled in different situations e g if an 
unset commitment is rejected also environmental events can 
lead χ to become true in which case the commitment 
becomes fulfilled without the debtor s contribution figure 
provides a graphic representation of commitment state 
transitions in this framework 
apart from a slightly different notation used to maintain 
a more detailed history of commitments we will extend 
them to also contain a deactivation condition ψ apart from 
ϕ which we call activation condition which causes any 
commitment to be cancelled if it becomes true 
 
more precisely l contains atomic propositions p 
 p q the usual connectives ∨ and ¬ with 
abbreviations ⇒ and ∧ as for semantics a function interpretation 
function i p ×env → ⊥ assigns a truth value to each 
proposition in each environmental state and the entailment 
relation e ϕ for e ∈ env and ϕ ∈ l is defined inductively 
e ϕ if ϕ ∈ p and i ϕ e e ¬ϕ if e ϕ e ϕ ∨ ψ 
if e ϕ or e ψ 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
d cs ← cs∪ ι c χ ⊕ ϕ ψ t ι s χ ⊕ ϕ ψ ∈ cs r ψ s ∈ u p a ι c χ ⊕ ϕ ψ ∈ cs 
a cs ← cs∪ ι a χ ⊕ ϕ ψ t ι p χ ⊕ ϕ ψ ∈ cs r ϕ ι a χ ⊕ ϕ ψ ∈ cs 
s cs ← cs∪ ι f χ ⊕ ϕ ψ t ι a χ ⊕ ϕ ψ ∈ cs r χ ι f χ ⊕ ϕ ψ ∈ cs 
f cs ← cs∪ ι f χ ⊕ ϕ ψ i→j 
t ι a χ ⊕ ϕ ψ i→j 
t− ∈ cs r done i a causes a χ 
v cs ← cs∪ ι v χ ⊕ ϕ ψ i→j 
t ι a χ ⊕ ϕ ψ i→j 
t− ∈ cs r done i a ¬causes a χ 
table environmental commitment processing rules for current run r with r t 
definition a commitment is a structure 
ι s χ ⊕ ϕ ψ i→j 
t 
where 
- ι is a unique commitment identifier 
- s denotes the commitment state any of unset 
pending active violated fulfilled or cancelled 
abbreviated by the respective initial 
- i is the debtor j is the creditor 
- χ ∈ l is the debitum i e the proposition that i 
commits to making true in front of j 
- ϕ ψ ∈ l are the activation deactivation conditions 
- and t is the instant in a run at which this 
commitment entered its current state s 
as an example 
x v received ⊕ received toys 
returned toys → 
 
denotes that agent violated commitment x towards agent 
 to pay him in timestep he was supposed to make 
the payment after receiving the toys unless he sent back the 
toys we introduce deactivation conditions so as to be able 
to completely revoke existing commitments sending back 
the money does not constitute a fulfillment of the original 
contract but instead an annulment thereof this provides 
us with the capability to define validity conditions using 
ϕ and ψ which is useful for things like deadlines for unset 
commitments if i don t get a response within time-steps 
my request will expire 
for brevity we sometimes omit indices or content 
elements when clear from the context in particular we often 
write γ for the content χ ⊕ ϕ ψ we write c for the set of 
all possible commitments and denote sets of commitments 
 so-called commitment stores by cs ∈ ℘fin c 
to handle the effects of environmental events and agent 
actions on a commitment store cs table introduces five 
commitment transition rules which are executed in each time 
step by the system or any observer who intends to clarify 
the status of existing commitments in the order shown the 
deactivation rule d is the first to fire and cancels any 
unset pending or active commitments if ψ becomes true for 
the remaining pending commitments 
 the activation rule a 
describes how these become active if ϕ becomes true note 
that when ϕ is true in subsequent states we check whether 
 
to avoid problems with contradictory commitment 
specifications e g when both ϕ and ψ become true we give 
deactivation strict precedence over activation 
this active commitment is contained in cs to avoid 
duplicates this is because we keep a full record of the 
commitment history for reasons which will become clear below 
rule s caters for serendipity i e fulfillment of 
commitments not brought about by the respective agent but 
simply by environmental changes that made the debitum true 
finally the fulfilment violation rules f v record whether 
the action performed by the debtor in the previous step 
 r done i a has caused the debitum χ of any 
commitment which became active in the previous timestep to 
become true we need only consider those commitments that 
became active in the previous step t − since we can 
verify their fulfilment status in t this verification hinges on a 
domain-dependent predicate causes a χ which we have not 
mentioned so far it should be true if action a is supposed 
to bring about χ and delineates the existing social notion 
of what constitutes a reasonable attempt to achieve χ in 
the given context its definition may range from requiring 
that χ has actually been achieved to allowing any action a 
that does not necessarily result in ¬χ 
 grounding 
in fornara and colombetti s and similar approaches 
the status of commitments is verifiable but they are not 
grounded in expectations about interaction such semantics 
 similar in style to what he have just defined in terms of 
cs update rules tell us what commitments exist and which 
state they are in but not how this will affect future agent 
behaviour 
to provide such grounding we introduce notions of 
compliant and expected behaviour an agent is behaving in 
compliance with its commitments if it always immediately 
fulfills all active commitments more precisely the behaviour 
of agent i is said to be compliant with cs at time t iff 
∀k ≤ t 
 
ι a γ i→j 
k ∈ cs ⇒ ι f γ i→j 
k ∈ cs 
 
though simple this definition of compliance is not very 
useful because it places constraints on css but not on actual 
agent functions to achieve this we can instead use the 
contents of the cs to restrict the range of admissible agent 
functions to those that are in accordance with it using the 
following definition 
definition for any run r ∈ r env a let cs r the 
set of commitments that has resulted from execution of r 
assuming that certain actions including messages create 
commitments or change their status the set of compliant 
agent functions with respect to a commitment store cs is 
 
while commitment identifiers adversely affect the 
readability of our notation they are necessary here to uniquely 
determine which pending commitment is activated 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
defined as 
compliant cs 
˘ 
gi ∈ gi env a 
˛ 
˛ 
∀r ∼ gi ι p χ ⊕ ϕ ψ i→j 
∈ cs r cs 
∀r r ι a χ ⊕ ϕ ψ i→j 
 r ∈ cs r ⇒ 
` 
∃a ∈ aci causes a χ ∧ gi r a 
´ ¯ 
what this definition captures is the following 
characterisation of a compliant agent function gi for all runs r that the 
agent function gi contributes to if r has created a pending 
commitment regarding χ then if this commitment becomes 
active at the end of some extension r of r in the future gi 
will cause the agent to perform an action a that causes χ 
next to cater for the anticipation of non-compliant 
behaviour we need to introduce a notion of expected 
behaviour that overrides compliant behaviour for this we 
introduce a second type of commitments which we will call 
expectations to avoid confusion and distinguish from 
ordinary now called normative commitments by using round 
brackets ι s γ i→j 
t they are treated exactly like other 
commitments in terms of the rules introduced above but 
express what the agent is expected to do in the non-normative 
sense of an objective prediction of behaviour rather than 
what it is supposed to do in a normative sense 
to define the notions we need below we introduce the 
following constructs 
cs ι s γ ∈ cs s ∈ u p a f v 
cs ι s γ ∈ cs ι s γ ∈ cs 
ι s γ ∈ cs s s ∈ u p a f v 
cs simply restricts the commitment store to all 
normative commitments hence compliant cs specifies what 
agents are supposed to do cs on the other hand 
overrides all normative commitment elements in cs for which 
an expectation also exists i e expectations are given 
precedence over the normative commitments with this we can 
define expected behaviour as 
expected cs compliant cs 
i e behaviour that adheres to expectations where such 
expectations exist and is compliant otherwise the 
separate parallel treatment of compliant and expected 
behaviour has two advantages firstly we can respond to 
unexpected compliant behaviour i e when we expect 
that someone will not obey their commitments we can still 
respond to it if they do and for example regain trust 
in them secondly we can cater for a variety of rules 
for translating commitment stores to actual future events 
which a reasoning agent can use in its planning process 
for the purposes of this paper we will assume that agents 
base their predictions about others on expected behaviour 
if it is different from compliant behaviour and that they 
predict compliant behaviour else 
 
note the quantification in this definition the property has 
to hold for every run that gave rise to ι and is compatible 
with gi in particular this must be independent of any 
part of the history e g other agents actions and previous 
environment states given cs r we also quantify over all 
extensions r of r i e fulfillment of the commitment has to 
happen if the appropriate conditions arise regardless of other 
factors 
 static acl semantics 
table shows an example for a small fragment of an acl 
semantics defined using our framework with two alternative 
definitions ac and ac for the semantics of the accept 
message type each of the so-called dialogue operators 
 similar to ai planning action schemata is defined using the 
graphical notation 
p 
a 
q 
where p a and q are schemata for preconditions messages 
 of a certain type and post-conditions respectively 
preconditions determine whether an action schema is 
applicable in a certain situation or not and contain formulae from 
l and or constraints on the current contents of cs 
postconditions contain changes to the knowledge base and 
modifications to cs i e they are interpreted like 
add deletelists in traditional ai planning for any such operator 
o p a q we define pre o p action o a and 
post o q all elements of a dialogue operator can 
contain logical variables in their pre- and post-conditions and 
sender receiver content variables in the action slot 
in our example fragment the operator rq for requests 
creates an unset commitment with a fresh identifier ι and 
current timestamp we assume that r time t ⇔ r t 
and there is a global system time that can be inspected by all 
agents and ac rj add a pending cancelled equivalent of 
ι to cs a fragment consisting of rq rj ac is 
equivalent to the standard semantics of the respective performative 
types defined in 
note that our operators only contain 
objectively verifiable pre- and post-conditions and if agents 
want to conform to it they need to comply with these 
operators in the following we will assume that agents always 
adhere to the acl specification syntactically 
 
using ac instead of ac enables us to exploit the 
power of our distinction between compliant and expected 
behaviour expressing that we don t trust i to adhere to the 
normal semantics of accept its postcondition specifies 
that expected cs is not restricted to behaviours that will 
fulfill the commitment but suggest that it has actually been 
cancelled at the same time we maintain the normative 
commitment that ι is pending so that i s behaviour would 
be seen to lie within compliant cs if i deviates from our 
 pessimistic expectation and does the right thing instead 
 dynamic semantics 
 defining dynamic semantics 
to define ds for acls we now introduce a state 
transition system in which each state specifies an ordinary 
 static commitment-based semantics and a range of 
agent pairs for which these semantics are assumed to apply 
 
note that we allow for requesting identical things before 
receiving a response and responding several times to the same 
request simple additional conditions can be introduced to 
avoid these effects which we omit here for lack of space the 
same is true of additional constraints to manage control flow 
issues in actual dialogues e g turn-taking 
 
this means that for an appropriate variable substitution 
ϑ r pre o ϑ holds when o is applied at r and that cs r 
is transformed according to post o ϑ after its application 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
rq 
time t new ι 
request i j ι γ 
cs ← cs ∪ ι u γ i→j 
t 
rj 
ι u γ j→i 
t ∈ cs time t 
reject i j ι γ 
cs ← cs ∪ ι c γ i→j 
t 
ac 
ι u γ j→i 
t ∈ cs time t 
accept i j ι γ 
cs ← cs ∪ ι p γ i→j 
t 
ac 
ι u γ j→i 
t ∈ cs time t 
accept i j ι γ 
cs ← cs ∪ ι p γ i→j 
t ∪ ι c γ i→j 
t 
table example commitment-based semantics for a small acl fragment 
ι v γ i→j 
∈ cs i ∪ j i 
s 
s 
∀ ι v γ i→j 
t ∈ cs ∃ ι f γ i→j 
t ∈ cs t t i 
figure fsm-like state transition diagram 
describing the δ-relation in a ds specification 
definition a dynamic semantics ds is a structure 
o s s δ where 
- o o o on a set of dialogue operators 
- s ⊆ ℘ o is a set of semantic states specified as 
subsets of dialogue operators which are valid in this state 
- s ∈ s is the initial semantic state 
- and the transition relation δ ⊆ s × ℘ c × ℘ ag × 
ag × s defines the transitions over s triggered by 
conditions expressed as elements of ℘ c c is the set 
of all possible commitments 
the meaning of a transition s c i j in jn s ∈ 
δ is as follows assume a mapping act ag × ag → s 
which specifies that the semantics of operators in s holds for 
messages sent from i to j then if cs ∈ c i e the current 
cs matches the constraint c given as a collection of possible 
css this will trigger a transition to state s for all pairs of 
agents in i j in jn for which the constraint was 
satisfied and will update act accordingly in other words 
the act mapping tracks which version of the semantics is 
valid for which pairs of communication partners over time 
 example 
to illustrate these concepts consider the following 
example let o rq rj ac ac s s s where 
s rq rj ac and s rq rj ac i e there are 
two possible states of the semantics which only differ in their 
definition of accept we call alternative versions of a single 
dialogue operator like ac and ac semantic variants we 
assume that initially act i j s for all agents i j ∈ ag 
we describe δ by the transition diagram shown in figure 
in this diagram edges carry labels c a where c is a 
constraint on the contents of cs followed by a description 
of the set of agent pairs a for which the transition should 
be made to the target state writing a s act− 
 s for 
the so-called range of agent pairs for which s is active we 
use agent variables like i and j and the wildcard symbol 
that can be bound to any agent in a s and we assume that 
this binding carries over to descriptions of a for example 
the edge with label ι v γ i→j 
∈ cs i ∪ j i 
can be interpreted as follows select all pairs i j ∈ a s 
for which ι v γ i→j 
∈ cs applies i e i has violated 
some commitment toward j and make s valid for the set 
of agents i k k ∈ a s ∪ j i this means that for 
all agents i who have lied s will become active for i j 
where j ∈ a s and s will also become active for j i 
the way the ds of the diagram above works is as 
follows initially the semantics says for every agent i that 
they will fulfill any commitment truthfully the use of ac 
ensures that expected behaviour is equivalent to compliant 
behaviour if an agent i violates a commitment once then 
s will become active for i towards all other agents so that 
they won t expect i to fulfill any future commitments 
moreover this will also apply to j i so that the culprit i should 
not expect the deceived agent j to keep its promises towards 
i either in the future however this will not affect 
expectations regarding their interactions with i by agents other 
than i i e they still have no right to violate their own 
commitments this reflects the idea that only agents that 
have been fooled are allowed to trespass only against 
those agents who trespassed against them however if 
i ever fulfills any commitment again after the latest 
violation this is ensured by the complex constraint used as a 
label for the transition from s to s the semantics in s 
will become valid for i again in this case though s will 
still be valid for the pair j i i e agent j will regain trust 
in i but cannot be expected to be trustworthy toward i ever 
again 
rather than suggesting that this is a particularly useful 
communication-inherent mechanism for sanctioning and 
rewarding specific kinds of behaviour this example serves to 
illustrate the expressiveness of our framework and the kind 
of distinctions it enables us to make 
 formal semantics 
the semantics of a ds can be defined inductively as 
follows let cs r denote the contents of the commitment 
store after run r as before we use the notation 
a δ cs i j cs i j ∈ c ∩ a s ∩ a 
to denote the set of agents that are to be moved from 
s to s due to transition rule δ s c a s ∈ δ given 
cs where cs i j is the set of commitments that mention i 
and or j in their sender receiver content slots in other 
words a δ cs contains those pairs of agents who are i 
mentioned in the commitments covered by the constraint c 
 ii contained in the range of s and iii explicitly listed in a 
as belonging to those pairs of agents that should be affected 
by the transition δ 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
definition the state of a dynamic semantics 
o s s δ after run r with immediate predecessor r 
is defined as a mapping actr as follows 
 r ε actε i j s for all i j ∈ ag 
 r ε 
actr i j 
 
 
 
s if ∃δ s c a s ∈ δ 
 i j ∈ a δ cs r 
actr i j else 
this maintains the property act− 
r s act− 
r s − 
a δ cs r which specifies that the agent pairs to be 
moved from s to s are removed from the range of s and 
added to the range of s 
what is not ensured by this definition is consistency of the 
state transition system i e making sure that the semantic 
successor state is uniquely identified for any state of the 
commitment store and previous state so that every agent 
pair is only assigned one active state in each step i e actr 
is actually a function for any r 
 integration 
once the ds itself has been specified we need to 
integrate the different components of our framework to monitor 
the dynamics of our acl semantics and its implications for 
expected agent behaviour 
starting with an initially empty commitment store cs 
and initial semantic state s such that actε i j s for any 
two agents i and j the agent or external observer observes 
 a partial subset of everything that is communicated in the 
system in each step by applying the commitment transition 
rules d a s f and v we can update cs accordingly 
ignoring any observed message sent from i to j that does 
not syntactically match the dialogue operator set defined 
in actr i j for a current run r after this update has been 
performed for all observed messages and actions in this cycle 
which should not depend on the ordering of messages 
 we 
can compute for any message sent from i to j the new value 
of actr i j depending on the semantic transition rules of 
the ds if r is the successor run of r with this we can 
then determine what the compliant and expected behaviour 
of agents will be under these new conditions 
thus an agent can use information about expected 
behaviour in its own planning processes by assuming that all 
agents involved will exhibit their expected rather than just 
compliant behaviours this prediction will not always be 
more accurate than under normal static acl semantics 
but since it is common knowledge that agents assume 
expected behaviour to occur and by virtue of the ds-acl 
specification have the right to do that most reasonable 
dynamic acl specifications will make provisions to ensure 
that it is safer to assume expected rather than fully 
compliant behaviour if they want to promote their use by agents 
 
one way of ensuring this is to require that ∀s ∈ 
s ∩ c s c a s ∈ δ s ∅ so that no two constraints 
pertaining to outgoing edges of s can be fulfilled by cs at 
a time in some cases this may be too coarse-grained - it 
would be sufficient for constraints to be mutually exclusive 
for the same pair of agents at any point in time - but this 
would have to be verified for an individual ds on a 
case-bycase basis 
 
this is the case for our operators because their pre- and 
post-conditions never concern or affect any commitments 
other than those that involve both i and j - avoiding any 
connection to third parties helps us keep the cs-update 
independent of the order in which observations are processed 
 complexity issues 
the main disadvantage of our approach is the space 
complexity of the dynamic acl specification if d is the number 
of dialogue operators in a language and b is the maximum 
number of semantic variants of a single dialogue operator 
within this language the ds specification would have to 
specify o db 
 states in many cases however most of the 
speech acts will not have different variants like rq and 
rj in our example and this may significantly reduce the 
number of ds states that need to be specified 
as for the run-time behaviour of our semantics 
processing mechanism we can assume that n messages actions are 
sent performed in each processing step in a system with n 
agents every commitment processing rule d s etc has 
to perform a pass over the contents of cs in the worst case 
every originally created commitment of which there may be 
nt after t steps may have immediately become pending 
active and violated which doesn t require any further physical 
actions so that every agent can create a new commitment 
in each step thus if any agent creates a new commitment 
in each step without ever fulfilling it this will result in the 
total size of cs being in o nt 
regarding semantic state transitions as many as n 
different pairs of agents could be affected in a single iteration by n 
messages assuming that the verification of cs-constraints 
for these transitions would take o nt this yields a total 
update time of o n 
t for tracking ds evolution this bound 
can be reduced to o n 
 if a quasi-stationarity 
assumption is made by limiting the window of earlier 
commitments that are being considered when verifying transition 
constraints to a constant size and thus obtaining a finite 
set of possible commitment stores 
 analysis and discussion 
the main strength of our framework is that it allows us 
to exploit the three main elements of reciprocity 
 reputation-based adaptation the ds adapts the 
expectations toward agent i according to i s previous 
behaviour by modifying the semantic state to better 
reflect this behaviour based on the assumption that it 
will repeat itself in the future 
 mutuality of expectations the ds adapts the 
expectations toward j s behaviour according to i s previous 
behaviour toward j to better reflect j s response to i s 
observed behaviour in particular allowing j to behave 
toward i as i behaved toward j earlier 
 recovery mechanisms the ds allows i to revert to an 
earlier semantic state after having undone a change in 
expectations by a further later change of behaviour 
 e g by means of redemption 
in open systems in which we cannot enforce certain 
behaviours these are effectively the only available means for 
indirect sanctions and rewards 
 
this is actually only a lower bound on the complexity for 
commitment processing which could become even worse if 
dominated by the complexity of verifying entailment 
however this would also hold for a static acl semantics 
 
for example this could be useful if we want to discard 
commitments whose status was last modified more than k 
time steps ago this is problematic as it might force us to 
discard certain unset pending commitments before they 
become pending active 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
there are two further dimensions that affect ds-based 
sanctioning and reward mechanisms and are orthogonal to 
the above one concerns the character of the semantic state 
changes i e whether it is a reward or punishment the other 
the degree of adaptation reputation-based mechanisms for 
example need not realistically reflect the behaviour of the 
culprit but may instead utilise immediate exaggerated 
stigmatisation of agents as a deterrent 
albeit simple our example ds described above makes use 
of all these aspects and apart from consistency and 
completeness it also satisfies some other useful properties 
 non-redundancy no two dialogue operators in o 
should have identical pre- and post-conditions and 
any two semantic variants of an operator must differ 
in terms of pre- and or post-conditions 
∀o o ∈ o pre o pre o ∧post o post o ⇒ o o 
∀o o ∈ o action o action o ⇒ 
pre o pre o ∨ post o post o 
 reachability of all semantic states any constraint 
causing a transition must be satisfiable in principle 
when using the dialogue operators and physical actions 
that are provided 
∀ s c a s ∈ δ ∃r ∈ r env a cs r ∩ c ∅ 
 distinction between expected and compliant 
behaviour the content of expectations must differ from 
that of normative commitments at least for some 
semantic variants giving rise to non-compliant 
expectations for some runs 
∃r ∈ r env a expected cs r compliant cs r 
 compliance deviance realisability it must be 
possible for agents in principle to comply with normative 
commitments or deviate from them in principle 
∃r ∈ r env a expected cs r ∅∧ 
compliant cs r ∅ 
while not absolutely essential these constitute desiderata 
for the design of ds-acls as they add to the simplicity 
and clarity of a given semantics specification our 
framework raises interesting questions regarding further potential 
properties of ds such as 
 respect for commitment autonomy the semantics 
must not allow an agent to create a pending 
commitment for another agent or to violate a commitment on 
behalf of another agent while in some cases some 
agents should be able to enforce commitments upon 
others this should generally be avoided to ensure agent 
autonomy 
 avoiding commitment inconsistency the acl must 
either disallow commitment to contradictory actions 
or beliefs or at least provide operators for rectifying 
such contradictory claims under contradictory 
commitments no possible behaviour can be 
compliantit is up to the designer to decide to which extent this 
should be permitted 
 unprejudiced judgement expected behaviour 
prediction must not deviate from compliant behaviour 
prediction if deviant behaviour has not been observed so 
far in particular this must hold for the initial semantic 
state this might not always be desirable as initial 
distrust is necessary in some systems but it increases 
the chances that agents will agree to participate in 
communication 
 convergence the semantic state of each of the 
dialogue operators will remain stable after a finite 
number of transitions regardless of any further agent 
behaviour 
 if this property holds this would imply that 
agents can stop tracking semantic state transitions 
after some amount of initial interaction the advantage 
of this is reduced complexity which of course comes at 
the price of giving up adaptiveness 
 forgiveness after initial deviance further compliant 
behaviour of an agent should lead to a semantic state 
that predicts compliant behaviour for that agent again 
here we have to trade off cautiousness against the 
provision of incentives to resume cooperative behaviour 
trusting an agent makes others vulnerable to 
exploitation - blacklisting an agent forever though might 
lead that agent to keep up its unpredictable and 
potentially malicious behaviour 
 equality unless this is required by domain-specific 
constraints the same dynamics of semantics should 
apply to all parties involved 
our simple example semantics satisfies all these 
properties apart from convergence many of the above 
properties are debatable as we have to trade off cautiousness 
against the provision of incentives for cooperative behaviour 
while we cannot make any general statements here 
regarding optimal ds-acl design our framework provides the 
tools to test and evaluate the performance of different such 
communication-inherent sanctioning and rewarding 
mechanisms i e social rules that do not presuppose ability to 
direct punishment or reward through physical actions in 
real-world applications 
 related work 
expectation-based reasoning about interaction was first 
proposed in considering the evolution of expectations 
described as probabilistic expectations of communication 
and action sequences the same authors suggested a more 
general framework for expectation-based communication 
semantics and argue for a consequentialist view of 
semantics that is based on defining the meaning of utterances 
in terms of their expected consequences and updating these 
expectations with new observations however their 
approach does not use an explicit notion of commitments 
which in our framework mediates between communication 
and behaviour-based grounding and provides a clear 
distinction between a normative notion of compliance and a 
more empirical notion of expectation 
grounding for mentalistic acl semantics has been 
investigated in where grounded information is viewed as 
information that is publicly expressed and accepted as 
being true by all the agents participating in a conversation 
like which bases the notion of publicly expressed on 
roles rather than internal states of agents these authors 
main concern is to provide a verifiable basis for determining 
the semantics of expressed mental states and commitments 
though our framework is only concerned with commitment 
to the achievement of states of affairs rather than exchanged 
information in a sense ds provides an alternative view by 
specifying what will happen if the assumptions on which 
what is publicly accepted is based are violated 
 
in a non-trivial sense i e when some initial transitions are 
possible in principle 
 the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
our framework is also related to deontic methods for the 
specification of obligations norms and sanctions in this 
area is the only framework that we are aware of which 
considers dynamic obligations norms and sanctions 
however as we have described above we solely utilise semantic 
evolution as a sanctioning and rewarding mechanism i e 
unlike this work we do not assume that agents can be directly 
punished or rewarded 
finally the fsm-like structure of the ds transition 
systems in combination with agent communication is 
reminiscent of work on electronic institutions but there the focus 
is on providing different means of communication in different 
scenes of the interaction process e g different protocols 
for different phases of market-based interaction whereas we 
focus on different semantic variants that are to be used in 
the same interaction context 
 conclusion 
this paper introduces dynamic semantics for acls as 
a method for dealing with some fundamental problems of 
agent communication in open systems the simple 
underlying idea being that different courses of agent behaviour can 
give rise to different interpretations of meaning of the 
messages exchanged among agents based on a common 
framework of commitment-based semantics we presented a notion 
of grounding for commitments based on notions of compliant 
and expected behaviour we then defined dynamic 
semantics as state transition systems over different semantic states 
that can be viewed as different versions of acl 
semantics in the traditional sense and can be easily associated 
with a planning-based view of reasoning about 
communication thereby our focus was on simplicity and on providing 
mechanisms for tracking semantic evolution in a 
down-toearth algorithmic fashion to ensure applicability to many 
different agent designs 
we discussed the properties of our framework showing 
how it can be used as a powerful communication-inherent 
mechanism for rewarding and sanctioning agent behaviour 
in open systems without compromising agent autonomy 
discussed its integration with agents planning processes 
complexity issues and presented a list of desiderata for the 
design of acls with such semantics 
currently we are working on fully-fledged specifications 
of dynamic semantics for more complex languages and on 
extending our approach to mentalistic semantics where we 
view statements about mental states as commitments 
regarding the rational implications of these mental states a 
simple example for this is that an agent commits itself to 
dropping an ostensible intention that it is claiming to 
maintain if that intention turns out to be unachievable in this 
context we are particularly interested in appropriate 
mechanisms to detect and respond to lying by interrogating 
suspicious agents and forcing them to commit themselves 
to sets of mental states publicly while sanctioning them 
when these are inconsistent with their actions 
 references 
 g boella r damiano j hulstijn and l van der 
torre acl semantics between social commitments 
and mental attitudes in proceedings of the 
international workshop on agent communication 
 w brauer m nickles m rovatsos g weiß and 
k f lorentzen expectation-oriented analysis and 
design in proceedings of the nd workshop on 
agent-oriented software engineering lncs 
 springer-verlag berlin 
 p r cohen and h j levesque communicative 
actions for artificial agents in proceedings of the first 
international conference on multi-agent systems 
pages - 
 p r cohen and c r perrault elements of a 
plan-based theory of speech acts cognitive science 
 - 
 m esteva j rodriguez j arcos c sierra and 
p garcia formalising agent mediated electronic 
institutions in catalan congres on ai pages - 
 
 n fornara and m colombetti operational 
specification of a commitment-based agent communication 
language in proceedings of the first international 
joint conference on autonomous agents and 
multiagent systems pages - bologna italy 
 acm press 
 b gaudou a herzig d longin and m nickles a 
new semantics for the fipa agent communication 
language based on social attitudes in proceedings of 
the th european conference on artificial 
intelligence riva del garda italy ios press 
 f guerin and j pitt denotational semantics for 
agent communication languages in proceedings of 
the fifth international conference on autonomous 
agents pages - acm press 
 m nickles m rovatsos and g weiss 
empiricalrational semantics of agent communication in 
proceedings of the third international joint 
conference on autonomous agents and multiagent 
systems new york ny 
 j pitt and a mamdani some remarks on the 
semantics of fipa s agent communication language 
autonomous agents and multi-agent systems 
 - 
 m rovatsos m nickles and g weiß interaction is 
meaning a new model for communication in open 
systems in proceedings of the second international 
joint conference on autonomous agents and 
multiagent systems melbourne australia 
 m d sadek dialogue acts are rational plans in 
proceedings of the esca etrw workshop on the 
structure of multimodal dialogue pages - 
 m singh agent communication languages 
rethinking the principles ieee computer 
 - 
 m singh a social semantics for agent communication 
languages in proceedings of the ijcai workshop on 
agent communication languages 
 m p singh a semantics for speech acts annals of 
mathematics and artificial intelligence - - 
 
 g weiß m nickles m rovatsos and f fischer 
specifying the intertwining of cooperation and 
autonomy in agent-based systems journal of 
networks and computer applications 
 m j wooldridge verifiable semantics for agent 
communication languages in proceedings of the third 
international conference on multi-agent systems 
pages - paris france 
the sixth intl joint conf on autonomous agents and multi-agent systems aamas 
